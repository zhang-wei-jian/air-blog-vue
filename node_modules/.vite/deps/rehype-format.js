import {
  SKIP,
  convert,
  visitParents
} from "./chunk-OKBCUQKU.js";
import {
  whitespace
} from "./chunk-WPRQBUUN.js";
import "./chunk-JEXKZRFY.js";

// node_modules/.pnpm/hast-util-is-element@3.0.0/node_modules/hast-util-is-element/lib/index.js
var isElement = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(element: unknown, test: Condition, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((element?: null | undefined) => false) &
   *   ((element: unknown, test?: null | undefined, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((element: unknown, test?: Test, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => boolean)
   * )}
   */
  /**
   * @param {unknown} [element]
   * @param {Test | undefined} [test]
   * @param {number | null | undefined} [index]
   * @param {Parents | null | undefined} [parent]
   * @param {unknown} [context]
   * @returns {boolean}
   */
  // eslint-disable-next-line max-params
  function(element2, test, index, parent, context) {
    const check = convertElement(test);
    if (index !== null && index !== void 0 && (typeof index !== "number" || index < 0 || index === Number.POSITIVE_INFINITY)) {
      throw new Error("Expected positive finite `index`");
    }
    if (parent !== null && parent !== void 0 && (!parent.type || !parent.children)) {
      throw new Error("Expected valid `parent`");
    }
    if ((index === null || index === void 0) !== (parent === null || parent === void 0)) {
      throw new Error("Expected both `index` and `parent`");
    }
    return looksLikeAnElement(element2) ? check.call(context, element2, index, parent) : false;
  }
);
var convertElement = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &
   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &
   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test | null | undefined} [test]
   * @returns {Check}
   */
  function(test) {
    if (test === null || test === void 0) {
      return element;
    }
    if (typeof test === "string") {
      return tagNameFactory(test);
    }
    if (typeof test === "object") {
      return anyFactory(test);
    }
    if (typeof test === "function") {
      return castFactory(test);
    }
    throw new Error("Expected function, string, or array as `test`");
  }
);
function anyFactory(tests) {
  const checks = [];
  let index = -1;
  while (++index < tests.length) {
    checks[index] = convertElement(tests[index]);
  }
  return castFactory(any);
  function any(...parameters) {
    let index2 = -1;
    while (++index2 < checks.length) {
      if (checks[index2].apply(this, parameters))
        return true;
    }
    return false;
  }
}
function tagNameFactory(check) {
  return castFactory(tagName);
  function tagName(element2) {
    return element2.tagName === check;
  }
}
function castFactory(testFunction) {
  return check;
  function check(value, index, parent) {
    return Boolean(
      looksLikeAnElement(value) && testFunction.call(
        this,
        value,
        typeof index === "number" ? index : void 0,
        parent || void 0
      )
    );
  }
}
function element(element2) {
  return Boolean(
    element2 && typeof element2 === "object" && "type" in element2 && element2.type === "element" && "tagName" in element2 && typeof element2.tagName === "string"
  );
}
function looksLikeAnElement(value) {
  return value !== null && typeof value === "object" && "type" in value && "tagName" in value;
}

// node_modules/.pnpm/hast-util-embedded@3.0.0/node_modules/hast-util-embedded/lib/index.js
var embedded = convertElement(
  /**
   * @param element
   * @returns {element is {tagName: 'audio' | 'canvas' | 'embed' | 'iframe' | 'img' | 'math' | 'object' | 'picture' | 'svg' | 'video'}}
   */
  function(element2) {
    return element2.tagName === "audio" || element2.tagName === "canvas" || element2.tagName === "embed" || element2.tagName === "iframe" || element2.tagName === "img" || element2.tagName === "math" || element2.tagName === "object" || element2.tagName === "picture" || element2.tagName === "svg" || element2.tagName === "video";
  }
);

// node_modules/.pnpm/hast-util-has-property@3.0.0/node_modules/hast-util-has-property/lib/index.js
var own = {}.hasOwnProperty;
function hasProperty(node, name) {
  const value = node.type === "element" && own.call(node.properties, name) && node.properties[name];
  return value !== null && value !== void 0 && value !== false;
}

// node_modules/.pnpm/hast-util-is-body-ok-link@3.0.0/node_modules/hast-util-is-body-ok-link/lib/index.js
var list = /* @__PURE__ */ new Set(["pingback", "prefetch", "stylesheet"]);
function isBodyOkLink(node) {
  if (node.type !== "element" || node.tagName !== "link") {
    return false;
  }
  if (node.properties.itemProp) {
    return true;
  }
  const rel = node.properties.rel;
  let index = -1;
  if (!Array.isArray(rel) || rel.length === 0) {
    return false;
  }
  while (++index < rel.length) {
    if (!list.has(String(rel[index]))) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/hast-util-phrasing@3.0.1/node_modules/hast-util-phrasing/lib/index.js
var basic = convertElement([
  "a",
  "abbr",
  // `area` is in fact only phrasing if it is inside a `map` element.
  // However, since `area`s are required to be inside a `map` element, and it’s
  // a rather involved check, it’s ignored here for now.
  "area",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "i",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "wbr"
]);
var meta = convertElement("meta");
function phrasing(value) {
  return Boolean(
    value.type === "text" || basic(value) || embedded(value) || isBodyOkLink(value) || meta(value) && hasProperty(value, "itemProp")
  );
}

// node_modules/.pnpm/html-whitespace-sensitive-tag-names@3.0.0/node_modules/html-whitespace-sensitive-tag-names/lib/index.js
var whitespaceSensitiveTagNames = [
  "pre",
  "script",
  "style",
  "textarea"
];

// node_modules/.pnpm/rehype-minify-whitespace@6.0.0/node_modules/rehype-minify-whitespace/lib/block.js
var blocks = [
  "address",
  // Flow content.
  "article",
  // Sections and headings.
  "aside",
  // Sections and headings.
  "blockquote",
  // Flow content.
  "body",
  // Page.
  "br",
  // Contribute whitespace intrinsically.
  "caption",
  // Similar to block.
  "center",
  // Flow content, legacy.
  "col",
  // Similar to block.
  "colgroup",
  // Similar to block.
  "dd",
  // Lists.
  "dialog",
  // Flow content.
  "dir",
  // Lists, legacy.
  "div",
  // Flow content.
  "dl",
  // Lists.
  "dt",
  // Lists.
  "figcaption",
  // Flow content.
  "figure",
  // Flow content.
  "footer",
  // Flow content.
  "form",
  // Flow content.
  "h1",
  // Sections and headings.
  "h2",
  // Sections and headings.
  "h3",
  // Sections and headings.
  "h4",
  // Sections and headings.
  "h5",
  // Sections and headings.
  "h6",
  // Sections and headings.
  "head",
  // Page.
  "header",
  // Flow content.
  "hgroup",
  // Sections and headings.
  "hr",
  // Flow content.
  "html",
  // Page.
  "legend",
  // Flow content.
  "li",
  // Block-like.
  "li",
  // Similar to block.
  "listing",
  // Flow content, legacy
  "main",
  // Flow content.
  "menu",
  // Lists.
  "nav",
  // Sections and headings.
  "ol",
  // Lists.
  "optgroup",
  // Similar to block.
  "option",
  // Similar to block.
  "p",
  // Flow content.
  "plaintext",
  // Flow content, legacy
  "pre",
  // Flow content.
  "section",
  // Sections and headings.
  "summary",
  // Similar to block.
  "table",
  // Similar to block.
  "tbody",
  // Similar to block.
  "td",
  // Block-like.
  "td",
  // Similar to block.
  "tfoot",
  // Similar to block.
  "th",
  // Block-like.
  "th",
  // Similar to block.
  "thead",
  // Similar to block.
  "tr",
  // Similar to block.
  "ul",
  // Lists.
  "wbr",
  // Contribute whitespace intrinsically.
  "xmp"
  // Flow content, legacy
];

// node_modules/.pnpm/rehype-minify-whitespace@6.0.0/node_modules/rehype-minify-whitespace/lib/content.js
var content = [
  // Form.
  "button",
  "input",
  "select",
  "textarea"
];

// node_modules/.pnpm/rehype-minify-whitespace@6.0.0/node_modules/rehype-minify-whitespace/lib/skippable.js
var skippable = [
  "area",
  "base",
  "basefont",
  "dialog",
  "datalist",
  "head",
  "link",
  "meta",
  "noembed",
  "noframes",
  "param",
  "rp",
  "script",
  "source",
  "style",
  "template",
  "track",
  "title"
];

// node_modules/.pnpm/rehype-minify-whitespace@6.0.0/node_modules/rehype-minify-whitespace/lib/index.js
var emptyOptions = {};
var ignorableNode = convert(["doctype", "comment"]);
function rehypeMinifyWhitespace(options) {
  const settings = options || emptyOptions;
  const collapse = collapseFactory(
    settings.newlines ? replaceNewlines : replaceWhitespace
  );
  return function(tree) {
    minify(tree, { collapse, whitespace: "normal" });
  };
}
function minify(node, state) {
  if ("children" in node) {
    const settings = { ...state };
    if (node.type === "root" || blocklike(node)) {
      settings.before = true;
      settings.after = true;
    }
    settings.whitespace = inferWhiteSpace(node, state);
    return all(node, settings);
  }
  if (node.type === "text") {
    if (state.whitespace === "normal") {
      return minifyText(node, state);
    }
    if (state.whitespace === "nowrap") {
      node.value = state.collapse(node.value);
    }
  }
  return { ignore: ignorableNode(node), stripAtStart: false, remove: false };
}
function minifyText(node, state) {
  const value = state.collapse(node.value);
  const result = { ignore: false, stripAtStart: false, remove: false };
  let start = 0;
  let end = value.length;
  if (state.before && removable(value.charAt(0))) {
    start++;
  }
  if (start !== end && removable(value.charAt(end - 1))) {
    if (state.after) {
      end--;
    } else {
      result.stripAtStart = true;
    }
  }
  if (start === end) {
    result.remove = true;
  } else {
    node.value = value.slice(start, end);
  }
  return result;
}
function all(parent, state) {
  let before = state.before;
  const after = state.after;
  const children = parent.children;
  let length = children.length;
  let index = -1;
  while (++index < length) {
    const result = minify(children[index], {
      ...state,
      after: collapsableAfter(children, index, after),
      before
    });
    if (result.remove) {
      children.splice(index, 1);
      index--;
      length--;
    } else if (!result.ignore) {
      before = result.stripAtStart;
    }
    if (content2(children[index])) {
      before = false;
    }
  }
  return { ignore: false, stripAtStart: Boolean(before || after), remove: false };
}
function collapsableAfter(nodes, index, after) {
  while (++index < nodes.length) {
    const node = nodes[index];
    let result = inferBoundary(node);
    if (result === void 0 && "children" in node && !skippable2(node)) {
      result = collapsableAfter(node.children, -1);
    }
    if (typeof result === "boolean") {
      return result;
    }
  }
  return after;
}
function inferBoundary(node) {
  if (node.type === "element") {
    if (content2(node)) {
      return false;
    }
    if (blocklike(node)) {
      return true;
    }
  } else if (node.type === "text") {
    if (!whitespace(node)) {
      return false;
    }
  } else if (!ignorableNode(node)) {
    return false;
  }
}
function content2(node) {
  return embedded(node) || isElement(node, content);
}
function blocklike(node) {
  return isElement(node, blocks);
}
function skippable2(node) {
  return Boolean(node.type === "element" && node.properties.hidden) || ignorableNode(node) || isElement(node, skippable);
}
function removable(character) {
  return character === " " || character === "\n";
}
function replaceNewlines(value) {
  const match = /\r?\n|\r/.exec(value);
  return match ? match[0] : " ";
}
function replaceWhitespace() {
  return " ";
}
function collapseFactory(replace) {
  return collapse;
  function collapse(value) {
    return String(value).replace(/[\t\n\v\f\r ]+/g, replace);
  }
}
function inferWhiteSpace(node, state) {
  if ("tagName" in node && node.properties) {
    switch (node.tagName) {
      case "listing":
      case "plaintext":
      case "script":
      case "style":
      case "xmp": {
        return "pre";
      }
      case "nobr": {
        return "nowrap";
      }
      case "pre": {
        return node.properties.wrap ? "pre-wrap" : "pre";
      }
      case "td":
      case "th": {
        return node.properties.noWrap ? "nowrap" : state.whitespace;
      }
      case "textarea": {
        return "pre-wrap";
      }
      default:
    }
  }
  return state.whitespace;
}

// node_modules/.pnpm/rehype-format@5.0.0/node_modules/rehype-format/lib/index.js
var emptyOptions2 = {};
var transformWhitespace = rehypeMinifyWhitespace({ newlines: true });
function rehypeFormat(options) {
  const settings = options || emptyOptions2;
  let indent = settings.indent || 2;
  let indentInitial = settings.indentInitial;
  if (typeof indent === "number") {
    indent = " ".repeat(indent);
  }
  if (indentInitial === null || indentInitial === void 0) {
    indentInitial = true;
  }
  return function(tree) {
    let head;
    transformWhitespace(tree);
    visitParents(tree, function(node, parents) {
      let index = -1;
      if (!("children" in node)) {
        return;
      }
      if (isElement(node, "head")) {
        head = true;
      }
      if (head && isElement(node, "body")) {
        head = void 0;
      }
      if (isElement(node, whitespaceSensitiveTagNames)) {
        return SKIP;
      }
      const children = node.children;
      let level = parents.length;
      if (children.length === 0 || !padding(node, head)) {
        return;
      }
      if (!indentInitial) {
        level--;
      }
      let eol;
      while (++index < children.length) {
        const child = children[index];
        if (child.type === "text" || child.type === "comment") {
          if (child.value.includes("\n")) {
            eol = true;
          }
          child.value = child.value.replace(
            / *\n/g,
            "$&" + String(indent).repeat(level)
          );
        }
      }
      const result = [];
      let previous;
      index = -1;
      while (++index < children.length) {
        const child = children[index];
        if (padding(child, head) || eol && !index) {
          addBreak(result, level, child);
          eol = true;
        }
        previous = child;
        result.push(child);
      }
      if (previous && (eol || padding(previous, head))) {
        if (whitespace(previous)) {
          result.pop();
          previous = result[result.length - 1];
        }
        addBreak(result, level - 1);
      }
      node.children = result;
    });
  };
  function addBreak(list2, level, next) {
    const tail = list2[list2.length - 1];
    const previous = tail && whitespace(tail) ? list2[list2.length - 2] : tail;
    const replace = (blank(previous) && blank(next) ? "\n\n" : "\n") + String(indent).repeat(Math.max(level, 0));
    if (tail && tail.type === "text") {
      tail.value = whitespace(tail) ? replace : tail.value + replace;
    } else {
      list2.push({ type: "text", value: replace });
    }
  }
  function blank(node) {
    return Boolean(
      node && node.type === "element" && settings.blanks && settings.blanks.length > 0 && settings.blanks.includes(node.tagName)
    );
  }
}
function padding(node, head) {
  return node.type === "root" || (node.type === "element" ? head || isElement(node, "script") || embedded(node) || !phrasing(node) : false);
}
export {
  rehypeFormat as default
};
//# sourceMappingURL=rehype-format.js.map
