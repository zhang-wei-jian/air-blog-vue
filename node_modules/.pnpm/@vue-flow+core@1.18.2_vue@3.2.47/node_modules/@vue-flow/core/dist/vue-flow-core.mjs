import { ref as ne, watch as ue, customRef as wr, getCurrentScope as di, onScopeDispose as Bt, unref as M, getCurrentInstance as tn, onMounted as Ve, nextTick as Ke, readonly as br, isRef as Er, computed as W, onBeforeMount as Sr, markRaw as nt, inject as He, defineComponent as ge, toRef as E, openBlock as oe, createElementBlock as ae, normalizeClass as qe, renderSlot as ye, h as le, effectScope as fi, watchEffect as An, provide as lt, onBeforeUnmount as hi, normalizeStyle as Le, createCommentVNode as be, createElementVNode as st, mergeProps as gi, createBlock as Te, resolveDynamicComponent as vi, Fragment as Ne, createTextVNode as Nr, toDisplayString as Bn, Teleport as Cr, normalizeProps as Mr, reactive as $r, toRefs as kr, renderList as ut, resolveComponent as pi, createVNode as je, withCtx as Ge, useSlots as Ir, onUnmounted as Or } from "vue";
var wo;
const to = typeof window < "u", Tr = (e) => typeof e < "u", Pr = (e) => typeof e == "boolean", Pe = (e) => typeof e == "function", Ie = (e) => typeof e == "number", Be = (e) => typeof e == "string", Dr = () => {
};
to && ((wo = window == null ? void 0 : window.navigator) != null && wo.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function Ye(e) {
  return typeof e == "function" ? e() : M(e);
}
function zr(e, t) {
  function n(...o) {
    return new Promise((i, r) => {
      Promise.resolve(e(() => t.apply(this, o), { fn: t, thisArg: this, args: o })).then(i).catch(r);
    });
  }
  return n;
}
const mi = (e) => e();
function Ar(e = mi) {
  const t = ne(!0);
  function n() {
    t.value = !1;
  }
  function o() {
    t.value = !0;
  }
  const i = (...r) => {
    t.value && e(...r);
  };
  return { isActive: br(t), pause: n, resume: o, eventFilter: i };
}
function bo(e, t = !1, n = "Timeout") {
  return new Promise((o, i) => {
    setTimeout(t ? () => i(n) : o, e);
  });
}
function Br(e) {
  return e;
}
function wn(e, t) {
  let n, o, i;
  const r = ne(!0), a = () => {
    r.value = !0, i();
  };
  ue(e, a, { flush: "sync" });
  const l = Pe(t) ? t : t.get, s = Pe(t) ? void 0 : t.set, u = wr((c, g) => (o = c, i = g, {
    get() {
      return r.value && (n = l(), r.value = !1), o(), n;
    },
    set(v) {
      s == null || s(v);
    }
  }));
  return Object.isExtensible(u) && (u.trigger = a), u;
}
function ht(e) {
  return di() ? (Bt(e), !0) : !1;
}
function Rr(e, t = !0) {
  tn() ? Ve(e) : t ? e() : Ke(e);
}
function Rn(e, t = !1) {
  function n(g, { flush: v = "sync", deep: w = !1, timeout: f, throwOnTimeout: d } = {}) {
    let _ = null;
    const S = [new Promise((A) => {
      _ = ue(e, (x) => {
        g(x) !== t && (_ == null || _(), A(x));
      }, {
        flush: v,
        deep: w,
        immediate: !0
      });
    })];
    return f != null && S.push(bo(f, d).then(() => Ye(e)).finally(() => _ == null ? void 0 : _())), Promise.race(S);
  }
  function o(g, v) {
    if (!Er(g))
      return n((x) => x === g, v);
    const { flush: w = "sync", deep: f = !1, timeout: d, throwOnTimeout: _ } = v ?? {};
    let y = null;
    const A = [new Promise((x) => {
      y = ue([e, g], ([C, T]) => {
        t !== (C === T) && (y == null || y(), x(C));
      }, {
        flush: w,
        deep: f,
        immediate: !0
      });
    })];
    return d != null && A.push(bo(d, _).then(() => Ye(e)).finally(() => (y == null || y(), Ye(e)))), Promise.race(A);
  }
  function i(g) {
    return n((v) => Boolean(v), g);
  }
  function r(g) {
    return o(null, g);
  }
  function a(g) {
    return o(void 0, g);
  }
  function l(g) {
    return n(Number.isNaN, g);
  }
  function s(g, v) {
    return n((w) => {
      const f = Array.from(w);
      return f.includes(g) || f.includes(Ye(g));
    }, v);
  }
  function u(g) {
    return c(1, g);
  }
  function c(g = 1, v) {
    let w = -1;
    return n(() => (w += 1, w >= g), v);
  }
  return Array.isArray(Ye(e)) ? {
    toMatch: n,
    toContains: s,
    changed: u,
    changedTimes: c,
    get not() {
      return Rn(e, !t);
    }
  } : {
    toMatch: n,
    toBe: o,
    toBeTruthy: i,
    toBeNull: r,
    toBeNaN: l,
    toBeUndefined: a,
    changed: u,
    changedTimes: c,
    get not() {
      return Rn(e, !t);
    }
  };
}
function pe(e) {
  return Rn(e);
}
var Eo = Object.getOwnPropertySymbols, Vr = Object.prototype.hasOwnProperty, Hr = Object.prototype.propertyIsEnumerable, Lr = (e, t) => {
  var n = {};
  for (var o in e)
    Vr.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Eo)
    for (var o of Eo(e))
      t.indexOf(o) < 0 && Hr.call(e, o) && (n[o] = e[o]);
  return n;
};
function Fr(e, t, n = {}) {
  const o = n, {
    eventFilter: i = mi
  } = o, r = Lr(o, [
    "eventFilter"
  ]);
  return ue(e, zr(i, t), r);
}
var Gr = Object.defineProperty, Yr = Object.defineProperties, Xr = Object.getOwnPropertyDescriptors, Ft = Object.getOwnPropertySymbols, yi = Object.prototype.hasOwnProperty, xi = Object.prototype.propertyIsEnumerable, So = (e, t, n) => t in e ? Gr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Ur = (e, t) => {
  for (var n in t || (t = {}))
    yi.call(t, n) && So(e, n, t[n]);
  if (Ft)
    for (var n of Ft(t))
      xi.call(t, n) && So(e, n, t[n]);
  return e;
}, Zr = (e, t) => Yr(e, Xr(t)), Kr = (e, t) => {
  var n = {};
  for (var o in e)
    yi.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Ft)
    for (var o of Ft(e))
      t.indexOf(o) < 0 && xi.call(e, o) && (n[o] = e[o]);
  return n;
};
function et(e, t, n = {}) {
  const o = n, {
    eventFilter: i
  } = o, r = Kr(o, [
    "eventFilter"
  ]), { eventFilter: a, pause: l, resume: s, isActive: u } = Ar(i);
  return { stop: Fr(e, t, Zr(Ur({}, r), {
    eventFilter: a
  })), pause: l, resume: s, isActive: u };
}
function _i(e) {
  var t;
  const n = Ye(e);
  return (t = n == null ? void 0 : n.$el) != null ? t : n;
}
const no = to ? window : void 0;
function oo(...e) {
  let t, n, o, i;
  if (Be(e[0]) || Array.isArray(e[0]) ? ([n, o, i] = e, t = no) : [t, n, o, i] = e, !t)
    return Dr;
  Array.isArray(n) || (n = [n]), Array.isArray(o) || (o = [o]);
  const r = [], a = () => {
    r.forEach((c) => c()), r.length = 0;
  }, l = (c, g, v, w) => (c.addEventListener(g, v, w), () => c.removeEventListener(g, v, w)), s = ue(() => [_i(t), Ye(i)], ([c, g]) => {
    a(), c && r.push(...n.flatMap((v) => o.map((w) => l(c, v, w, g))));
  }, { immediate: !0, flush: "post" }), u = () => {
    s(), a();
  };
  return ht(u), u;
}
const Wr = (e) => typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
function No(...e) {
  let t, n, o = {};
  e.length === 3 ? (t = e[0], n = e[1], o = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], o = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const { target: i = no, eventName: r = "keydown", passive: a = !1 } = o, l = Wr(t);
  return oo(i, r, (u) => {
    l(u) && n(u);
  }, a);
}
function qr(e, t = !1) {
  const n = ne(), o = () => n.value = Boolean(e());
  return o(), Rr(o, t), n;
}
function jr(e) {
  return JSON.parse(JSON.stringify(e));
}
const Vn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Hn = "__vueuse_ssr_handlers__";
Vn[Hn] = Vn[Hn] || {};
Vn[Hn];
var Co = Object.getOwnPropertySymbols, Qr = Object.prototype.hasOwnProperty, Jr = Object.prototype.propertyIsEnumerable, ea = (e, t) => {
  var n = {};
  for (var o in e)
    Qr.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && Co)
    for (var o of Co(e))
      t.indexOf(o) < 0 && Jr.call(e, o) && (n[o] = e[o]);
  return n;
};
function ta(e, t, n = {}) {
  const o = n, { window: i = no } = o, r = ea(o, ["window"]);
  let a;
  const l = qr(() => i && "ResizeObserver" in i), s = () => {
    a && (a.disconnect(), a = void 0);
  }, u = ue(() => _i(e), (g) => {
    s(), l.value && i && g && (a = new ResizeObserver(t), a.observe(g, r));
  }, { immediate: !0, flush: "post" }), c = () => {
    s(), u();
  };
  return ht(c), {
    isSupported: l,
    stop: c
  };
}
var Mo;
(function(e) {
  e.UP = "UP", e.RIGHT = "RIGHT", e.DOWN = "DOWN", e.LEFT = "LEFT", e.NONE = "NONE";
})(Mo || (Mo = {}));
var na = Object.defineProperty, $o = Object.getOwnPropertySymbols, oa = Object.prototype.hasOwnProperty, ia = Object.prototype.propertyIsEnumerable, ko = (e, t, n) => t in e ? na(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ra = (e, t) => {
  for (var n in t || (t = {}))
    oa.call(t, n) && ko(e, n, t[n]);
  if ($o)
    for (var n of $o(t))
      ia.call(t, n) && ko(e, n, t[n]);
  return e;
};
const aa = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
ra({
  linear: Br
}, aa);
function xt(e, t, n, o = {}) {
  var i, r, a;
  const {
    clone: l = !1,
    passive: s = !1,
    eventName: u,
    deep: c = !1,
    defaultValue: g
  } = o, v = tn(), w = n || (v == null ? void 0 : v.emit) || ((i = v == null ? void 0 : v.$emit) == null ? void 0 : i.bind(v)) || ((a = (r = v == null ? void 0 : v.proxy) == null ? void 0 : r.$emit) == null ? void 0 : a.bind(v == null ? void 0 : v.proxy));
  let f = u;
  t || (t = "modelValue"), f = u || f || `update:${t.toString()}`;
  const d = (y) => l ? Pe(l) ? l(y) : jr(y) : y, _ = () => Tr(e[t]) ? d(e[t]) : g;
  if (s) {
    const y = _(), S = ne(y);
    return ue(() => e[t], (A) => S.value = d(A)), ue(S, (A) => {
      (A !== e[t] || c) && w(f, A);
    }, { deep: c }), S;
  } else
    return W({
      get() {
        return _();
      },
      set(y) {
        w(f, y);
      }
    });
}
function X(e = () => {
}) {
  const t = ne(/* @__PURE__ */ new Set());
  e && t.value.add(e);
  const n = (r) => {
    t.value.delete(r);
  };
  return {
    on: (r) => {
      t.value.has(e) && t.value.delete(e), t.value.add(r);
      const a = () => n(r);
      return ht(a), {
        off: a
      };
    },
    off: n,
    trigger: (r) => Promise.all(Array.from(t.value).map((a) => a(r))),
    fns: t
  };
}
const la = ["production", "prod"];
function wt(e, ...t) {
  la.includes(process.env.NODE_ENV || "") || console.warn(`[Vue Flow]: ${e}`, ...t);
}
function sa() {
  return {
    edgesChange: X(),
    nodesChange: X(),
    nodeDoubleClick: X(),
    nodeClick: X(),
    nodeMouseEnter: X(),
    nodeMouseMove: X(),
    nodeMouseLeave: X(),
    nodeContextMenu: X(),
    nodeDragStart: X(),
    nodeDrag: X(),
    nodeDragStop: X(),
    nodesInitialized: X(),
    miniMapNodeClick: X(),
    miniMapNodeDoubleClick: X(),
    miniMapNodeMouseEnter: X(),
    miniMapNodeMouseMove: X(),
    miniMapNodeMouseLeave: X(),
    connect: X(),
    connectStart: X(),
    connectEnd: X(),
    clickConnectStart: X(),
    clickConnectEnd: X(),
    paneReady: X(),
    move: X(),
    moveStart: X(),
    moveEnd: X(),
    selectionDragStart: X(),
    selectionDrag: X(),
    selectionDragStop: X(),
    selectionContextMenu: X(),
    selectionStart: X(),
    selectionEnd: X(),
    viewportChangeStart: X(),
    viewportChange: X(),
    viewportChangeEnd: X(),
    paneScroll: X(),
    paneClick: X(),
    paneContextMenu: X(),
    paneMouseEnter: X(),
    paneMouseMove: X(),
    paneMouseLeave: X(),
    edgeContextMenu: X(),
    edgeMouseEnter: X(),
    edgeMouseMove: X(),
    edgeMouseLeave: X(),
    edgeDoubleClick: X(),
    edgeClick: X(),
    edgeUpdateStart: X(),
    edgeUpdate: X(),
    edgeUpdateEnd: X(),
    updateNodeInternals: X(),
    error: X((e) => wt(e.message))
  };
}
function ua(e, t) {
  Sr(() => {
    for (const [n, o] of Object.entries(t.value)) {
      const i = (r) => {
        e(n, r);
      };
      o.on(i), ht(() => {
        o.off(i);
      });
    }
  });
}
var he = /* @__PURE__ */ ((e) => (e.MISSING_VIEWPORT_DIMENSIONS = "MISSING_VIEWPORT_DIMENSIONS", e.NODE_NOT_FOUND = "NODE_NOT_FOUND", e.NODE_MISSING_PARENT = "NODE_MISSING_PARENT", e.NODE_TYPE_MISSING = "NODE_TYPE_MISSING", e.NODE_EXTENT_INVALID = "NODE_EXTENT_INVALID", e.EDGE_INVALID = "EDGE_INVALID", e.EDGE_NOT_FOUND = "EDGE_NOT_FOUND", e.EDGE_SOURCE_MISSING = "EDGE_SOURCE_MISSING", e.EDGE_TARGET_MISSING = "EDGE_TARGET_MISSING", e.EDGE_TYPE_MISSING = "EDGE_TYPE_MISSING", e.EDGE_SOURCE_TARGET_SAME = "EDGE_SOURCE_TARGET_SAME", e.EDGE_SOURCE_TARGET_MISSING = "EDGE_SOURCE_TARGET_MISSING", e.EDGE_ORPHANED = "EDGE_ORPHANED", e))(he || {});
const bn = {
  MISSING_VIEWPORT_DIMENSIONS: () => "The Vue Flow parent container needs a width and a height to render the graph",
  NODE_NOT_FOUND: (e) => `Node not found
Node: ${e}`,
  NODE_MISSING_PARENT: (e, t) => `Node is missing a parent
Node: ${e}
Parent: ${t}`,
  NODE_TYPE_MISSING: (e) => `Node type is missing
Type: ${e}`,
  NODE_EXTENT_INVALID: (e) => `Only child nodes can use a parent extent
Node: ${e}`,
  EDGE_INVALID: (e) => `An edge needs a source and a target
Edge: ${e}`,
  EDGE_SOURCE_MISSING: (e, t) => `Edge source is missing
Edge: ${e} 
Source: ${t}`,
  EDGE_TARGET_MISSING: (e, t) => `Edge target is missing
Edge: ${e} 
Target: ${t}`,
  EDGE_TYPE_MISSING: (e) => `Edge type is missing
Type: ${e}`,
  EDGE_SOURCE_TARGET_SAME: (e, t, n) => `Edge source and target are the same
Edge: ${e} 
Source: ${t} 
Target: ${n}`,
  EDGE_SOURCE_TARGET_MISSING: (e, t, n) => `Edge source or target is missing
Edge: ${e} 
Source: ${t} 
Target: ${n}`,
  EDGE_ORPHANED: (e) => `Edge was orphaned (suddenly missing source or target) and has been removed
Edge: ${e}`,
  EDGE_NOT_FOUND: (e) => `Edge not found
Edge: ${e}`
};
class ve extends Error {
  constructor(t, ...n) {
    var o;
    super((o = bn[t]) == null ? void 0 : o.call(bn, ...n)), this.code = t;
  }
}
const io = () => typeof window < "u" ? window : { chrome: !1 };
function Io(e) {
  return {
    ...e.computedPosition || { x: 0, y: 0 },
    width: e.dimensions.width || 0,
    height: e.dimensions.height || 0
  };
}
function Ln(e, t) {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * o);
}
function nn(e) {
  return {
    width: e.offsetWidth,
    height: e.offsetHeight
  };
}
function ct(e, t = 0, n = 1) {
  return Math.min(Math.max(e, t), n);
}
function ro(e, t) {
  return {
    x: ct(e.x, t[0][0], t[1][0]),
    y: ct(e.y, t[0][1], t[1][1])
  };
}
function Oo(e) {
  const t = e.getRootNode(), n = io();
  return "elementFromPoint" in t ? t : n.document;
}
function De(e) {
  return e && "id" in e && "source" in e && "target" in e;
}
function wi(e) {
  return De(e) && "sourceNode" in e && "targetNode" in e;
}
function ao(e) {
  return e && "id" in e && !De(e);
}
function Re(e) {
  return ao(e) && "computedPosition" in e;
}
function ca(e) {
  return !!e.width && !!e.height && !!e.x && !!e.y;
}
function da(e, t = {}) {
  let n = t;
  return Re(e) || (n = {
    type: e.type ?? t.type ?? "default",
    dimensions: nt({
      width: 0,
      height: 0
    }),
    handleBounds: {
      source: [],
      target: []
    },
    computedPosition: nt({
      z: 0,
      ...e.position
    }),
    draggable: void 0,
    selectable: void 0,
    connectable: void 0,
    focusable: void 0,
    selected: !1,
    dragging: !1,
    resizing: !1,
    initialized: !1,
    ...t,
    data: de(e.data) ? e.data : {},
    events: nt(de(e.events) ? e.events : {})
  }), Object.assign({}, n, e, { id: e.id.toString() });
}
function lo(e, t = {}) {
  const n = de(e.events) ? e.events : t.events && de(t.events) ? t.events : {}, o = de(e.data) ? e.data : t.data && de(t.data) ? t.data : {};
  return t = wi(e) ? t : {
    ...t,
    sourceHandle: (e.sourceHandle ? e.sourceHandle.toString() : void 0) || t.sourceHandle,
    targetHandle: (e.targetHandle ? e.targetHandle.toString() : void 0) || t.targetHandle,
    type: e.type ?? t.type ?? "default",
    source: e.source.toString() || t.source,
    target: e.target.toString() || t.target,
    updatable: e.updatable ?? t.updatable,
    selectable: e.selectable ?? t.selectable,
    focusable: e.focusable ?? t.focusable,
    data: o,
    events: nt(n),
    label: (e.label && !Be(e.label) ? nt(e.label) : e.label) || t.label,
    interactionWidth: e.interactionWidth || t.interactionWidth
  }, Object.assign({}, t, e, { id: e.id.toString() });
}
function bi(e, t, n) {
  if (!ao(e))
    return [];
  const o = n === "source" ? "target" : "source", i = t.filter((r) => De(r) && r[o] === e.id).map((r) => De(r) && r[n]);
  return t.filter((r) => i.includes(r.id));
}
function Od(e, t) {
  return bi(e, t, "target");
}
function Td(e, t) {
  return bi(e, t, "source");
}
function on({ source: e, sourceHandle: t, target: n, targetHandle: o }) {
  return `vueflow__edge-${e}${t ?? ""}-${n}${o ?? ""}`;
}
function Ei(e, t) {
  return t.some(
    (n) => De(n) && n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)
  );
}
function Pd(e, t, n) {
  if (!e.source || !e.target)
    return wt("Can't create edge. An edge needs a source and a target."), t;
  let o;
  return De(e) ? o = { ...e } : o = {
    ...e,
    id: on(e)
  }, o = lo(o, n), Ei(o, t) || t.push(o), t;
}
function Dd(e, t, n) {
  if (!t.source || !t.target)
    return wt("Can't create new edge. An edge needs a source and a target."), n;
  const o = n.find((r) => De(r) && r.id === e.id);
  if (!o)
    return wt(`The old edge with id=${e.id} does not exist.`), n;
  const i = {
    ...e,
    id: on(t),
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(o), 1, i), n.filter((r) => r.id !== e.id);
}
function fa({ x: e, y: t }, { x: n, y: o, zoom: i }) {
  return {
    x: e * i + n,
    y: t * i + o
  };
}
function so({ x: e, y: t }, { x: n, y: o, zoom: i }, r, [a, l]) {
  const s = {
    x: (e - n) / i,
    y: (t - o) / i
  };
  return r ? {
    x: a * Math.round(s.x / a),
    y: l * Math.round(s.y / l)
  } : s;
}
function Si(e, t) {
  return {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x2, t.x2),
    y2: Math.max(e.y2, t.y2)
  };
}
function Gt({ x: e, y: t, width: n, height: o }) {
  return {
    x: e,
    y: t,
    x2: e + n,
    y2: t + o
  };
}
function Ni({ x: e, y: t, x2: n, y2: o }) {
  return {
    x: e,
    y: t,
    width: n - e,
    height: o - t
  };
}
function zd(e, t) {
  return Ni(Si(Gt(e), Gt(t)));
}
function uo(e) {
  const t = e.reduce(
    (n, { computedPosition: o = { x: 0, y: 0 }, dimensions: i = { width: 0, height: 0 } } = {}) => Si(
      n,
      Gt({
        ...o,
        ...i
      })
    ),
    { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 }
  );
  return Ni(t);
}
function Ad({ x: e, y: t }, { x: n, y: o, zoom: i }) {
  return {
    x: e * i + n,
    y: t * i + o
  };
}
function Ci(e, t, { x: n, y: o, zoom: i } = { x: 0, y: 0, zoom: 1 }, r = !1, a = !1) {
  const l = {
    x: (t.x - n) / i,
    y: (t.y - o) / i,
    width: t.width / i,
    height: t.height / i
  };
  return e.filter((s) => {
    const { computedPosition: u = { x: 0, y: 0 }, dimensions: c = { width: 0, height: 0 }, selectable: g } = s;
    if (a && !g)
      return !1;
    const v = { ...u, width: c.width || 0, height: c.height || 0 }, w = Ln(l, v), f = typeof c.width > "u" || typeof c.height > "u" || c.width === 0 || c.height === 0, d = r && w > 0, _ = c.width * c.height;
    return f || d || w >= _;
  });
}
function rn(e, t) {
  const n = e.map((o) => o.id);
  return t.filter((o) => n.includes(o.source) || n.includes(o.target));
}
function Yt(e, t, n, o, i, r = 0.1, a = { x: 0, y: 0 }) {
  const l = t / (e.width * (1 + r)), s = n / (e.height * (1 + r)), u = Math.min(l, s), c = ct(u, o, i), g = e.x + e.width / 2, v = e.y + e.height / 2, w = t / 2 - g * c + (a.x ?? 0), f = n / 2 - v * c + (a.y ?? 0);
  return { x: w, y: f, zoom: c };
}
function ha(e, t) {
  return {
    x: t.x + e.x,
    y: t.y + e.y,
    z: (e.z > t.z ? e.z : t.z) + 1
  };
}
function Mi(e, t) {
  if (!e.parentNode)
    return !1;
  const n = t(e.parentNode);
  return n ? n.selected ? !0 : Mi(n, t) : !1;
}
function Ue(e, t) {
  return typeof e > "u" ? "" : typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((o) => `${o}=${e[o]}`).join("&")}`;
}
function de(e) {
  return typeof M(e) < "u";
}
function ga(e, t, n) {
  if (!e.source || !e.target)
    return n(new ve(he.EDGE_INVALID, e.id)), !1;
  let o;
  return De(e) ? o = e : o = {
    ...e,
    id: on(e)
  }, o = lo(o), Ei(o, t) ? !1 : o;
}
function va(e, t, n, o, i, r) {
  if (!t.source || !t.target)
    return r(new ve(he.EDGE_INVALID, e.id)), !1;
  const a = o(e.id);
  if (!a)
    return r(new ve(he.EDGE_NOT_FOUND, e.id)), !1;
  const { id: l, ...s } = e, u = {
    ...s,
    id: i ? on(t) : l,
    source: t.source,
    target: t.target,
    sourceHandle: t.sourceHandle,
    targetHandle: t.targetHandle
  };
  return n.splice(n.indexOf(a), 1, u), u;
}
function To(e, t, n, o) {
  const i = {}, r = e.map((l) => {
    const s = da(l, {
      ...n(l.id),
      parentNode: l.parentNode
    });
    return l.parentNode && (i[l.parentNode] = !0), s;
  }), a = [...r, ...t];
  return r.forEach((l) => {
    const s = a.find((u) => u.id === l.parentNode);
    l.parentNode && !s && o(new ve(he.NODE_MISSING_PARENT, l.id, l.parentNode)), (l.parentNode || i[l.id]) && (i[l.id] && (l.isParent = !0), s && (s.isParent = !0));
  }), r;
}
var J = /* @__PURE__ */ ((e) => (e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom", e))(J || {}), co = /* @__PURE__ */ ((e) => (e.Partial = "partial", e.Full = "full", e))(co || {}), Xe = /* @__PURE__ */ ((e) => (e.Bezier = "default", e.SimpleBezier = "simple-bezier", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e))(Xe || {}), Qe = /* @__PURE__ */ ((e) => (e.Strict = "strict", e.Loose = "loose", e))(Qe || {}), Fn = /* @__PURE__ */ ((e) => (e.Arrow = "arrow", e.ArrowClosed = "arrowclosed", e))(Fn || {}), Xt = /* @__PURE__ */ ((e) => (e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal", e))(Xt || {}), pa = /* @__PURE__ */ ((e) => (e.TopLeft = "top-left", e.TopCenter = "top-center", e.TopRight = "top-right", e.BottomLeft = "bottom-left", e.BottomCenter = "bottom-center", e.BottomRight = "bottom-right", e))(pa || {});
const Po = Symbol("vueFlow"), $i = Symbol("nodeId"), ki = Symbol("nodeRef"), Ii = Symbol("edgeId"), Oi = Symbol("edgeRef"), an = Symbol("slots");
function ma(e) {
  const t = e ?? He($i, ""), n = He(ki, null), { findNode: o, getEdges: i, emits: r } = ce(), a = o(t);
  return a || r.error(new ve(he.NODE_NOT_FOUND, t)), {
    id: t,
    nodeEl: n,
    node: a,
    parentNode: W(() => a.parentNode ? o(a.parentNode) : void 0),
    connectedEdges: W(() => rn([a], i.value))
  };
}
function fo(e) {
  return "clientX" in e;
}
function ot(e, t) {
  var r, a;
  const n = fo(e), o = n ? e.clientX : (r = e.touches) == null ? void 0 : r[0].clientX, i = n ? e.clientY : (a = e.touches) == null ? void 0 : a[0].clientY;
  return {
    x: o - ((t == null ? void 0 : t.left) ?? 0),
    y: i - ((t == null ? void 0 : t.top) ?? 0)
  };
}
function Ut(e, t, n) {
  const o = ((n == null ? void 0 : n.x) ?? 0) + t.x, i = ((n == null ? void 0 : n.y) ?? 0) + t.y, r = (n == null ? void 0 : n.width) ?? t.width, a = (n == null ? void 0 : n.height) ?? t.height;
  switch (e) {
    case J.Top:
      return {
        x: o + r / 2,
        y: i
      };
    case J.Right:
      return {
        x: o + r,
        y: i + a / 2
      };
    case J.Bottom:
      return {
        x: o + r / 2,
        y: i + a
      };
    case J.Left:
      return {
        x: o,
        y: i + a / 2
      };
  }
}
function Do(e = [], t) {
  return e.length ? !t || e.length === 1 ? e[0] : t && e.find((n) => n.id === t) || null : null;
}
function ya(e, t, n, o, i, r) {
  const a = Ut(
    n,
    {
      ...e.dimensions,
      ...e.computedPosition
    },
    t
  ), l = Ut(
    r,
    {
      ...o.dimensions,
      ...o.computedPosition
    },
    i
  );
  return {
    sourceX: a.x,
    sourceY: a.y,
    targetX: l.x,
    targetY: l.y
  };
}
function xa({
  sourcePos: e,
  targetPos: t,
  sourceWidth: n,
  sourceHeight: o,
  targetWidth: i,
  targetHeight: r,
  width: a,
  height: l,
  viewport: s
}) {
  const u = {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x + n, t.x + i),
    y2: Math.max(e.y + o, t.y + r)
  };
  u.x === u.x2 && (u.x2 += 1), u.y === u.y2 && (u.y2 += 1);
  const c = Gt({
    x: (0 - s.x) / s.zoom,
    y: (0 - s.y) / s.zoom,
    width: a / s.zoom,
    height: l / s.zoom
  }), g = Math.max(0, Math.min(c.x2, u.x2) - Math.max(c.x, u.x)), v = Math.max(0, Math.min(c.y2, u.y2) - Math.max(c.y, u.y));
  return Math.ceil(g * v) > 0;
}
function _a(e, t, n = !1) {
  let o = -1;
  const i = e.reduce((r, a) => {
    const l = Ie(a.zIndex);
    let s = l ? a.zIndex : 0;
    const u = t(a.source), c = t(a.target);
    return !u || !c || (n && (s = l ? a.zIndex : Math.max(u.computedPosition.z || 0, c.computedPosition.z || 0)), r[s] ? r[s].push(a) : r[s] = [a], o = s > o ? s : o), r;
  }, {});
  return Object.entries(Object.keys(i).length ? i : { 0: [] }).map(([r, a]) => {
    const l = +r;
    return {
      edges: a,
      level: l,
      isMaxLevel: l === o
    };
  });
}
function En(e) {
  e == null || e.classList.remove("valid", "connecting", "vue-flow__handle-valid", "vue-flow__handle-connecting");
}
function zo(e, t, n, o) {
  return (t[n] || []).reduce((i, r) => (`${e.id}-${r.id}-${n}` !== o && i.push({
    id: r.id || null,
    type: n,
    nodeId: e.id,
    ...Ut(
      r.position,
      {
        ...e.dimensions,
        ...e.computedPosition
      },
      r
    )
  }), i), []);
}
function wa(e, t, n) {
  let o = null, i = 1 / 0;
  return n.forEach((r) => {
    const a = Math.sqrt((r.x - e.x) ** 2 + (r.y - e.y) ** 2);
    a <= t && a < i && (i = a, o = r);
  }), o;
}
function Ao(e, t, n, o, i, r, a, l, s, u) {
  const c = r === "target", g = l.querySelector(`.vue-flow__handle[data-id="${t == null ? void 0 : t.nodeId}-${t == null ? void 0 : t.id}-${t == null ? void 0 : t.type}"]`), { x: v, y: w } = ot(e), f = l.elementFromPoint(v, w), d = f != null && f.classList.contains("vue-flow__handle") ? f : g, _ = {
    handleDomNode: d,
    isValid: !1,
    connection: { source: "", target: "", sourceHandle: null, targetHandle: null },
    endHandle: null
  };
  if (d) {
    const y = Ti(void 0, d), S = d.getAttribute("data-nodeid"), A = d.getAttribute("data-handleid"), x = d.classList.contains("connectable"), C = d.classList.contains("connectableend"), T = {
      source: c ? S : o,
      sourceHandle: c ? A : i,
      target: c ? o : S,
      targetHandle: c ? i : A
    };
    _.connection = T, x && C && (n === Qe.Strict ? c && y === "source" || !c && y === "target" : S !== o || A !== i) && (_.endHandle = {
      nodeId: S,
      handleId: A,
      type: y
    }, _.isValid = a(T, {
      edges: s,
      sourceNode: u(T.source),
      targetNode: u(T.target)
    }));
  }
  return _;
}
function ba({ nodes: e, nodeId: t, handleId: n, handleType: o }) {
  return e.reduce((i, r) => {
    const { handleBounds: a } = r;
    let l = [], s = [];
    return a && (l = zo(r, a, "source", `${t}-${n}-${o}`), s = zo(r, a, "target", `${t}-${n}-${o}`)), i.push(...l, ...s), i;
  }, []);
}
function Ti(e, t) {
  return e || (t != null && t.classList.contains("target") ? "target" : t != null && t.classList.contains("source") ? "source" : null);
}
function Ea(e, t) {
  let n = null;
  return t ? n = "valid" : e && !t && (n = "invalid"), n;
}
function Bo(e, t, n) {
  return e < t ? ct(Math.abs(e - t), 1, 50) / 50 : e > n ? -ct(Math.abs(e - n), 1, 50) / 50 : 0;
}
function Pi(e, t) {
  const n = Bo(e.x, 35, t.width - 35) * 20, o = Bo(e.y, 35, t.height - 35) * 20;
  return [n, o];
}
function It() {
  return !0;
}
function Di({
  handleId: e,
  nodeId: t,
  type: n,
  isValidConnection: o,
  edgeUpdaterType: i,
  onEdgeUpdate: r,
  onEdgeUpdateEnd: a
}) {
  const l = W(() => M(n) === "target"), s = W(() => M(t)), u = W(() => M(e)), c = W(() => M(i)), {
    vueFlowRef: g,
    connectionMode: v,
    connectionRadius: w,
    connectOnClick: f,
    connectionClickStartHandle: d,
    nodesConnectable: _,
    autoPanOnConnect: y,
    findNode: S,
    panBy: A,
    getNodes: x,
    startConnection: C,
    updateConnection: T,
    endConnection: p,
    emits: G,
    viewport: R,
    edges: I,
    isValidConnection: H
  } = ce();
  let te = null, q = !1, m = null;
  function L(P) {
    var D;
    const K = fo(P), Y = Oo(P.target);
    if (K && P.button === 0 || !K) {
      let U = function(se) {
        Z = ot(se, O), B = wa(
          so(Z, R.value, !1, [1, 1]),
          w.value,
          Q
        ), N || (ee(), N = !0);
        const fe = Ao(
          se,
          B,
          v.value,
          s.value,
          u.value,
          l.value ? "target" : "source",
          re,
          Y,
          I.value,
          S
        );
        if (te = fe.connection, q = fe.isValid, m = fe.handleDomNode, T(
          B && q ? fa(
            {
              x: B.x,
              y: B.y
            },
            R.value
          ) : Z,
          fe.endHandle,
          Ea(!!B, q)
        ), !B && !q && !m)
          return En(V);
        te && te.source !== te.target && m && (En(V), V = m, m.classList.add("connecting", "vue-flow__handle-connecting"), m.classList.toggle("valid", q), m.classList.toggle("vue-flow__handle-valid", q));
      }, j = function(se) {
        (B || m) && te && q && (r ? r(se, te) : G.connect(te)), G.connectEnd(se), c && (a == null || a(se)), En(V), cancelAnimationFrame(k), p(se), N = !1, q = !1, te = null, m = null, Y.removeEventListener("mousemove", U), Y.removeEventListener("mouseup", j), Y.removeEventListener("touchmove", U), Y.removeEventListener("touchend", j);
      };
      const ie = S(s.value);
      let re = o || H.value || It;
      !re && ie && (re = (l ? ie.isValidSourcePos : ie.isValidTargetPos) || It);
      let B, k = 0;
      const { x: F, y: h } = ot(P), b = Y == null ? void 0 : Y.elementFromPoint(F, h), z = Ti(c.value, b), O = (D = g.value) == null ? void 0 : D.getBoundingClientRect();
      if (!O || !z)
        return;
      let V, Z = ot(P, O), N = !1;
      const Q = ba({
        nodes: x.value,
        nodeId: s.value,
        handleId: u.value,
        handleType: z
      }), ee = () => {
        if (!y)
          return;
        const [se, fe] = Pi(Z, O);
        A({ x: se, y: fe }), k = requestAnimationFrame(ee);
      };
      C(
        {
          nodeId: s.value,
          handleId: u.value,
          type: z
        },
        {
          x: F - O.left,
          y: h - O.top
        },
        P
      ), G.connectStart({ event: P, nodeId: s.value, handleId: u.value, handleType: z }), Y.addEventListener("mousemove", U), Y.addEventListener("mouseup", j), Y.addEventListener("touchmove", U), Y.addEventListener("touchend", j);
    }
  }
  function $(P) {
    if (f.value)
      if (!d.value)
        G.clickConnectStart({ event: P, nodeId: s.value, handleId: u.value }), C({ nodeId: s.value, type: M(n), handleId: u.value }, void 0, P, !0);
      else {
        let K = o || H.value || It;
        const Y = S(s.value);
        if (!K && Y && (K = (l ? Y.isValidSourcePos : Y.isValidTargetPos) || It), Y && (typeof Y.connectable > "u" ? _.value : Y.connectable) === !1)
          return;
        const D = Oo(P.target), { connection: U, isValid: j } = Ao(
          P,
          {
            nodeId: s.value,
            id: u.value,
            type: M(n)
          },
          v.value,
          d.value.nodeId,
          d.value.handleId || null,
          d.value.type,
          K,
          D,
          I.value,
          S
        ), ie = U.source === U.target;
        j && !ie && G.connect(U), G.clickConnectEnd(P), p(P, !0);
      }
  }
  return {
    handlePointerDown: L,
    handleClick: $
  };
}
function Sa(e, t) {
  const n = {};
  for (const o in e)
    t.includes(o) || Object.defineProperty(n, o, {
      enumerable: !0,
      get: () => e[o]
    });
  return n;
}
const Na = ["data-id", "data-handleid", "data-nodeid", "data-handlepos"], Ca = {
  name: "Handle",
  compatConfig: { MODE: 3 }
}, Zt = /* @__PURE__ */ ge({
  ...Ca,
  props: {
    id: null,
    type: null,
    position: { default: J.Top },
    isValidConnection: { type: Function },
    connectable: { type: [Boolean, String, Function], default: void 0 },
    connectableStart: { type: Boolean, default: !0 },
    connectableEnd: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = Sa(e, ["position", "connectable", "connectableStart", "connectableEnd", "id", "isValidConnection"]), n = E(t, "type", "source"), {
      connectionStartHandle: o,
      connectionClickStartHandle: i,
      connectionEndHandle: r,
      vueFlowRef: a,
      nodesConnectable: l,
      noDragClassName: s,
      noPanClassName: u
    } = ce(), { id: c, node: g, nodeEl: v, connectedEdges: w } = ma(), f = ne(), d = W(() => e.id ?? `${c}__handle-${e.position}`), _ = W(() => typeof e.connectableStart < "u" ? e.connectableStart : !0), y = W(() => typeof e.connectableEnd < "u" ? e.connectableEnd : !0), { handlePointerDown: S, handleClick: A } = Di({
      nodeId: c,
      handleId: d,
      isValidConnection: e.isValidConnection,
      type: n
    }), x = W(() => Be(e.connectable) && e.connectable === "single" ? !w.value.some((R) => {
      const I = R[`${n.value}Handle`];
      return R[n.value] !== c ? !1 : I ? I === d.value : !0;
    }) : Pe(e.connectable) ? e.connectable(g, w.value) : de(e.connectable) ? e.connectable : l.value), C = W(
      () => {
        var R, I, H, te, q, m;
        return ((R = o.value) == null ? void 0 : R.nodeId) === c && ((I = o.value) == null ? void 0 : I.handleId) === d.value && ((H = o.value) == null ? void 0 : H.type) === n.value || ((te = r.value) == null ? void 0 : te.nodeId) === c && ((q = r.value) == null ? void 0 : q.handleId) === d.value && ((m = r.value) == null ? void 0 : m.type) === n.value;
      }
    ), T = W(
      () => {
        var R, I, H;
        return ((R = i.value) == null ? void 0 : R.nodeId) === c && ((I = i.value) == null ? void 0 : I.handleId) === d.value && ((H = i.value) == null ? void 0 : H.type) === n.value;
      }
    );
    pe(() => g.initialized).toBe(!0, { flush: "post" }).then(() => {
      var $;
      const R = ($ = g.handleBounds[n.value]) == null ? void 0 : $.find((P) => P.id === d.value);
      if (!a.value || R)
        return;
      const I = a.value.querySelector(".vue-flow__transformationpane");
      if (!v || !f.value || !I || !d.value)
        return;
      const H = v.value.getBoundingClientRect(), te = f.value.getBoundingClientRect(), q = window.getComputedStyle(I), { m22: m } = new window.DOMMatrixReadOnly(q.transform), L = {
        id: d.value,
        position: e.position,
        x: (te.left - H.left) / m,
        y: (te.top - H.top) / m,
        ...nn(f.value)
      };
      g.handleBounds[n.value] = [...g.handleBounds[n.value] ?? [], L];
    });
    function p(R) {
      const I = fo(R);
      x.value && _.value && (I && R.button === 0 || !I) && S(R);
    }
    function G(R) {
      !c || !i.value && !_.value || x.value && A(R);
    }
    return (R, I) => (oe(), ae("div", {
      ref_key: "handle",
      ref: f,
      "data-id": `${M(c)}-${M(d)}-${M(n)}`,
      "data-handleid": M(d),
      "data-nodeid": M(c),
      "data-handlepos": e.position,
      class: qe(["vue-flow__handle", [
        `vue-flow__handle-${e.position}`,
        `vue-flow__handle-${M(d)}`,
        M(s),
        M(u),
        M(n),
        {
          connectable: M(x),
          connecting: M(T),
          connectablestart: M(_),
          connectableend: M(y),
          connectionindicator: M(x) && (M(_) && !M(C) || M(y) && M(C))
        }
      ]]),
      onMousedown: p,
      onTouchstartPassive: p,
      onClick: G
    }, [
      ye(R.$slots, "default", { id: e.id })
    ], 42, Na));
  }
}), ln = function({
  sourcePosition: e = J.Bottom,
  targetPosition: t = J.Top,
  label: n,
  connectable: o = !0,
  isValidTargetPos: i,
  isValidSourcePos: r
}) {
  return [
    le(Zt, { type: "target", position: t, connectable: o, isValidConnection: i }),
    typeof n != "string" && n ? le(n) : le("div", { innerHTML: n }),
    le(Zt, { type: "source", position: e, connectable: o, isValidConnection: r })
  ];
};
ln.props = ["sourcePosition", "targetPosition", "label", "isValidTargetPos", "isValidSourcePos", "connectable"];
ln.inheritAttrs = !1;
ln.compatConfig = { MODE: 3 };
const Ma = ln, sn = function({
  sourcePosition: e = J.Bottom,
  label: t,
  connectable: n = !0,
  isValidSourcePos: o
}) {
  return [
    typeof t != "string" && t ? le(t) : le("div", { innerHTML: t }),
    le(Zt, { type: "source", position: e, connectable: n, isValidConnection: o })
  ];
};
sn.props = ["sourcePosition", "label", "isValidSourcePos", "connectable"];
sn.inheritAttrs = !1;
sn.compatConfig = { MODE: 3 };
const $a = sn, un = function({
  targetPosition: e = J.Top,
  label: t,
  connectable: n = !0,
  isValidTargetPos: o
}) {
  return [
    le(Zt, { type: "target", position: e, connectable: n, isValidConnection: o }),
    typeof t != "string" && t ? le(t) : le("div", { innerHTML: t })
  ];
};
un.props = ["targetPosition", "label", "isValidTargetPos", "connectable"];
un.inheritAttrs = !1;
un.compatConfig = { MODE: 3 };
const ka = un;
function Ro(e, t, n) {
  let o = e;
  do {
    if (o && o.matches(t))
      return !0;
    if (o === n)
      return !1;
    o = o.parentElement;
  } while (o);
  return !1;
}
function Ia(e, t, n, o, i) {
  return e.filter(
    (r) => (r.selected || r.id === i) && (!r.parentNode || !Mi(r, o)) && (r.draggable || t && typeof r.draggable > "u")
  ).map(
    (r) => {
      var a, l;
      return nt({
        id: r.id,
        position: r.position || { x: 0, y: 0 },
        distance: {
          x: n.x - ((a = r.computedPosition) == null ? void 0 : a.x) || 0,
          y: n.y - ((l = r.computedPosition) == null ? void 0 : l.y) || 0
        },
        from: r.computedPosition,
        extent: r.extent,
        parentNode: r.parentNode,
        dimensions: r.dimensions
      });
    }
  );
}
function Sn({
  id: e,
  dragItems: t,
  findNode: n
}) {
  const o = t.map((i) => n(i.id));
  return [e ? o.find((i) => i.id === e) : o[0], o];
}
function Oa(e) {
  switch (e.length) {
    case 1:
      return [e[0], e[0], e[0], e[0]];
    case 2:
      return [e[0], e[1], e[0], e[1]];
    case 3:
      return [e[0], e[1], e[2], e[1]];
    default:
      return e || [0, 0, 0, 0];
  }
}
function Ta(e, t, n) {
  const [o, i, r, a] = typeof e != "string" ? Oa(e.padding) : [0, 0, 0, 0];
  return n && Ie(n.computedPosition.x) && Ie(n.computedPosition.y) && Ie(n.dimensions.width) && Ie(n.dimensions.height) ? [
    [n.computedPosition.x + a, n.computedPosition.y + o],
    [
      n.computedPosition.x + (n.dimensions.width - t.dimensions.width) - i,
      n.computedPosition.y + (n.dimensions.height - t.dimensions.height) - r
    ]
  ] : !1;
}
function Pa(e, t, n, o) {
  var r;
  let i = e.extent || n;
  if (e.extent === "parent" || !Array.isArray(e.extent) && ((r = e.extent) == null ? void 0 : r.range) === "parent")
    if (e.parentNode && o && e.dimensions.width && e.dimensions.height) {
      const a = Ta(e.extent, e, o);
      a && (i = a);
    } else
      t(new ve(he.NODE_EXTENT_INVALID, e.id)), i = n;
  else if (Array.isArray(e.extent) && e.extent && o) {
    const a = o.computedPosition.x, l = o.computedPosition.y;
    i = [
      [e.extent[0][0] + a, e.extent[0][1] + l],
      [e.extent[1][0] + a, e.extent[1][1] + l]
    ];
  }
  return i;
}
function ho(e, t, n, o, i) {
  const r = Pa(e, n, o, i), a = ro(t, r);
  return {
    position: {
      x: a.x - ((i == null ? void 0 : i.computedPosition.x) || 0),
      y: a.y - ((i == null ? void 0 : i.computedPosition.y) || 0)
    },
    computedPosition: a
  };
}
function zi() {
  const { getSelectedNodes: e, nodeExtent: t, updateNodePositions: n, findNode: o, snapGrid: i, snapToGrid: r, nodesDraggable: a, emits: l } = ce();
  return (s, u = !1) => {
    const c = r.value ? i.value[0] : 5, g = r.value ? i.value[1] : 5, v = u ? 4 : 1, w = s.x * c * v, f = s.y * g * v, d = e.value.filter((_) => _.draggable || a && typeof _.draggable > "u").map((_) => {
      const y = { x: _.computedPosition.x + w, y: _.computedPosition.y + f }, { computedPosition: S } = ho(
        _,
        y,
        l.error,
        t.value,
        _.parentNode ? o(_.parentNode) : void 0
      );
      return {
        id: _.id,
        position: S,
        from: _.position,
        distance: { x: s.x, y: s.y },
        dimensions: _.dimensions
      };
    });
    n(d, !0, !1);
  };
}
function Da() {
  return {
    doubleClick: X(),
    click: X(),
    mouseEnter: X(),
    mouseMove: X(),
    mouseLeave: X(),
    contextMenu: X(),
    dragStart: X(),
    drag: X(),
    dragStop: X()
  };
}
function za(e, t) {
  const n = Da();
  return n.doubleClick.on((o) => {
    var i, r;
    t.nodeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.nodeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.nodeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.nodeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.nodeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.nodeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.dragStart.on((o) => {
    var i, r;
    t.nodeDragStart(o), (r = (i = e.events) == null ? void 0 : i.dragStart) == null || r.call(i, o);
  }), n.drag.on((o) => {
    var i, r;
    t.nodeDrag(o), (r = (i = e.events) == null ? void 0 : i.drag) == null || r.call(i, o);
  }), n.dragStop.on((o) => {
    var i, r;
    t.nodeDragStop(o), (r = (i = e.events) == null ? void 0 : i.dragStop) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
function Aa() {
  const { viewport: e, snapGrid: t, snapToGrid: n } = ce();
  return ({ sourceEvent: o }) => {
    const i = o.touches ? o.touches[0].clientX : o.clientX, r = o.touches ? o.touches[0].clientY : o.clientY, a = {
      x: (i - e.value.x) / e.value.zoom,
      y: (r - e.value.y) / e.value.zoom
    };
    return {
      xSnapped: n.value ? t.value[0] * Math.round(a.x / t.value[0]) : a.x,
      ySnapped: n.value ? t.value[1] * Math.round(a.y / t.value[1]) : a.y,
      ...a
    };
  };
}
function Vo(e, t, n) {
  const o = t.querySelectorAll(`.vue-flow__handle${e}`);
  if (!o || !o.length)
    return;
  const i = Array.from(o), r = t.getBoundingClientRect();
  return i.map((a) => {
    const l = a.getBoundingClientRect();
    return {
      id: a.getAttribute("data-handleid"),
      position: a.getAttribute("data-handlepos"),
      x: (l.left - r.left) / n,
      y: (l.top - r.top) / n,
      ...nn(a)
    };
  });
}
function Gn(e, t, n, o, i, r = !1, a) {
  i.value = !1, e.selected ? (r || e.selected && t) && (o([e]), Ke(a.blur)) : n([e]);
}
var Ba = { value: () => {
} };
function cn() {
  for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
    if (!(o = arguments[e] + "") || o in n || /[\s.]/.test(o))
      throw new Error("illegal type: " + o);
    n[o] = [];
  }
  return new Rt(n);
}
function Rt(e) {
  this._ = e;
}
function Ra(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var o = "", i = n.indexOf(".");
    if (i >= 0 && (o = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: o };
  });
}
Rt.prototype = cn.prototype = {
  constructor: Rt,
  on: function(e, t) {
    var n = this._, o = Ra(e + "", n), i, r = -1, a = o.length;
    if (arguments.length < 2) {
      for (; ++r < a; )
        if ((i = (e = o[r]).type) && (i = Va(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++r < a; )
      if (i = (e = o[r]).type)
        n[i] = Ho(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = Ho(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new Rt(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), o = 0, i, r; o < i; ++o)
        n[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (r = this._[e], o = 0, i = r.length; o < i; ++o)
      r[o].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var o = this._[e], i = 0, r = o.length; i < r; ++i)
      o[i].value.apply(t, n);
  }
};
function Va(e, t) {
  for (var n = 0, o = e.length, i; n < o; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function Ho(e, t, n) {
  for (var o = 0, i = e.length; o < i; ++o)
    if (e[o].name === t) {
      e[o] = Ba, e = e.slice(0, o).concat(e.slice(o + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Yn = "http://www.w3.org/1999/xhtml";
const Lo = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Yn,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function dn(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), Lo.hasOwnProperty(t) ? { space: Lo[t], local: e } : e;
}
function Ha(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Yn && t.documentElement.namespaceURI === Yn ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function La(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Ai(e) {
  var t = dn(e);
  return (t.local ? La : Ha)(t);
}
function Fa() {
}
function go(e) {
  return e == null ? Fa : function() {
    return this.querySelector(e);
  };
}
function Ga(e) {
  typeof e != "function" && (e = go(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, l = o[i] = new Array(a), s, u, c = 0; c < a; ++c)
      (s = r[c]) && (u = e.call(s, s.__data__, c, r)) && ("__data__" in s && (u.__data__ = s.__data__), l[c] = u);
  return new xe(o, this._parents);
}
function Ya(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Xa() {
  return [];
}
function Bi(e) {
  return e == null ? Xa : function() {
    return this.querySelectorAll(e);
  };
}
function Ua(e) {
  return function() {
    return Ya(e.apply(this, arguments));
  };
}
function Za(e) {
  typeof e == "function" ? e = Ua(e) : e = Bi(e);
  for (var t = this._groups, n = t.length, o = [], i = [], r = 0; r < n; ++r)
    for (var a = t[r], l = a.length, s, u = 0; u < l; ++u)
      (s = a[u]) && (o.push(e.call(s, s.__data__, u, a)), i.push(s));
  return new xe(o, i);
}
function Ri(e) {
  return function() {
    return this.matches(e);
  };
}
function Vi(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Ka = Array.prototype.find;
function Wa(e) {
  return function() {
    return Ka.call(this.children, e);
  };
}
function qa() {
  return this.firstElementChild;
}
function ja(e) {
  return this.select(e == null ? qa : Wa(typeof e == "function" ? e : Vi(e)));
}
var Qa = Array.prototype.filter;
function Ja() {
  return Array.from(this.children);
}
function el(e) {
  return function() {
    return Qa.call(this.children, e);
  };
}
function tl(e) {
  return this.selectAll(e == null ? Ja : el(typeof e == "function" ? e : Vi(e)));
}
function nl(e) {
  typeof e != "function" && (e = Ri(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, l = o[i] = [], s, u = 0; u < a; ++u)
      (s = r[u]) && e.call(s, s.__data__, u, r) && l.push(s);
  return new xe(o, this._parents);
}
function Hi(e) {
  return new Array(e.length);
}
function ol() {
  return new xe(this._enter || this._groups.map(Hi), this._parents);
}
function Kt(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Kt.prototype = {
  constructor: Kt,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function il(e) {
  return function() {
    return e;
  };
}
function rl(e, t, n, o, i, r) {
  for (var a = 0, l, s = t.length, u = r.length; a < u; ++a)
    (l = t[a]) ? (l.__data__ = r[a], o[a] = l) : n[a] = new Kt(e, r[a]);
  for (; a < s; ++a)
    (l = t[a]) && (i[a] = l);
}
function al(e, t, n, o, i, r, a) {
  var l, s, u = /* @__PURE__ */ new Map(), c = t.length, g = r.length, v = new Array(c), w;
  for (l = 0; l < c; ++l)
    (s = t[l]) && (v[l] = w = a.call(s, s.__data__, l, t) + "", u.has(w) ? i[l] = s : u.set(w, s));
  for (l = 0; l < g; ++l)
    w = a.call(e, r[l], l, r) + "", (s = u.get(w)) ? (o[l] = s, s.__data__ = r[l], u.delete(w)) : n[l] = new Kt(e, r[l]);
  for (l = 0; l < c; ++l)
    (s = t[l]) && u.get(v[l]) === s && (i[l] = s);
}
function ll(e) {
  return e.__data__;
}
function sl(e, t) {
  if (!arguments.length)
    return Array.from(this, ll);
  var n = t ? al : rl, o = this._parents, i = this._groups;
  typeof e != "function" && (e = il(e));
  for (var r = i.length, a = new Array(r), l = new Array(r), s = new Array(r), u = 0; u < r; ++u) {
    var c = o[u], g = i[u], v = g.length, w = ul(e.call(c, c && c.__data__, u, o)), f = w.length, d = l[u] = new Array(f), _ = a[u] = new Array(f), y = s[u] = new Array(v);
    n(c, g, d, _, y, w, t);
    for (var S = 0, A = 0, x, C; S < f; ++S)
      if (x = d[S]) {
        for (S >= A && (A = S + 1); !(C = _[A]) && ++A < f; )
          ;
        x._next = C || null;
      }
  }
  return a = new xe(a, o), a._enter = l, a._exit = s, a;
}
function ul(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function cl() {
  return new xe(this._exit || this._groups.map(Hi), this._parents);
}
function dl(e, t, n) {
  var o = this.enter(), i = this, r = this.exit();
  return typeof e == "function" ? (o = e(o), o && (o = o.selection())) : o = o.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? r.remove() : n(r), o && i ? o.merge(i).order() : i;
}
function fl(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, i = n.length, r = o.length, a = Math.min(i, r), l = new Array(i), s = 0; s < a; ++s)
    for (var u = n[s], c = o[s], g = u.length, v = l[s] = new Array(g), w, f = 0; f < g; ++f)
      (w = u[f] || c[f]) && (v[f] = w);
  for (; s < i; ++s)
    l[s] = n[s];
  return new xe(l, this._parents);
}
function hl() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var o = e[t], i = o.length - 1, r = o[i], a; --i >= 0; )
      (a = o[i]) && (r && a.compareDocumentPosition(r) ^ 4 && r.parentNode.insertBefore(a, r), r = a);
  return this;
}
function gl(e) {
  e || (e = vl);
  function t(g, v) {
    return g && v ? e(g.__data__, v.__data__) : !g - !v;
  }
  for (var n = this._groups, o = n.length, i = new Array(o), r = 0; r < o; ++r) {
    for (var a = n[r], l = a.length, s = i[r] = new Array(l), u, c = 0; c < l; ++c)
      (u = a[c]) && (s[c] = u);
    s.sort(t);
  }
  return new xe(i, this._parents).order();
}
function vl(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function pl() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function ml() {
  return Array.from(this);
}
function yl() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length; i < r; ++i) {
      var a = o[i];
      if (a)
        return a;
    }
  return null;
}
function xl() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function _l() {
  return !this.node();
}
function wl(e) {
  for (var t = this._groups, n = 0, o = t.length; n < o; ++n)
    for (var i = t[n], r = 0, a = i.length, l; r < a; ++r)
      (l = i[r]) && e.call(l, l.__data__, r, i);
  return this;
}
function bl(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function El(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Sl(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Nl(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Cl(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Ml(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function $l(e, t) {
  var n = dn(e);
  if (arguments.length < 2) {
    var o = this.node();
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
  }
  return this.each((t == null ? n.local ? El : bl : typeof t == "function" ? n.local ? Ml : Cl : n.local ? Nl : Sl)(n, t));
}
function Li(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function kl(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Il(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Ol(e, t, n) {
  return function() {
    var o = t.apply(this, arguments);
    o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n);
  };
}
function Tl(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? kl : typeof t == "function" ? Ol : Il)(e, t, n ?? "")) : dt(this.node(), e);
}
function dt(e, t) {
  return e.style.getPropertyValue(t) || Li(e).getComputedStyle(e, null).getPropertyValue(t);
}
function Pl(e) {
  return function() {
    delete this[e];
  };
}
function Dl(e, t) {
  return function() {
    this[e] = t;
  };
}
function zl(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function Al(e, t) {
  return arguments.length > 1 ? this.each((t == null ? Pl : typeof t == "function" ? zl : Dl)(e, t)) : this.node()[e];
}
function Fi(e) {
  return e.trim().split(/^|\s+/);
}
function vo(e) {
  return e.classList || new Gi(e);
}
function Gi(e) {
  this._node = e, this._names = Fi(e.getAttribute("class") || "");
}
Gi.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Yi(e, t) {
  for (var n = vo(e), o = -1, i = t.length; ++o < i; )
    n.add(t[o]);
}
function Xi(e, t) {
  for (var n = vo(e), o = -1, i = t.length; ++o < i; )
    n.remove(t[o]);
}
function Bl(e) {
  return function() {
    Yi(this, e);
  };
}
function Rl(e) {
  return function() {
    Xi(this, e);
  };
}
function Vl(e, t) {
  return function() {
    (t.apply(this, arguments) ? Yi : Xi)(this, e);
  };
}
function Hl(e, t) {
  var n = Fi(e + "");
  if (arguments.length < 2) {
    for (var o = vo(this.node()), i = -1, r = n.length; ++i < r; )
      if (!o.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? Vl : t ? Bl : Rl)(n, t));
}
function Ll() {
  this.textContent = "";
}
function Fl(e) {
  return function() {
    this.textContent = e;
  };
}
function Gl(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Yl(e) {
  return arguments.length ? this.each(e == null ? Ll : (typeof e == "function" ? Gl : Fl)(e)) : this.node().textContent;
}
function Xl() {
  this.innerHTML = "";
}
function Ul(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Zl(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Kl(e) {
  return arguments.length ? this.each(e == null ? Xl : (typeof e == "function" ? Zl : Ul)(e)) : this.node().innerHTML;
}
function Wl() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function ql() {
  return this.each(Wl);
}
function jl() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Ql() {
  return this.each(jl);
}
function Jl(e) {
  var t = typeof e == "function" ? e : Ai(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function es() {
  return null;
}
function ts(e, t) {
  var n = typeof e == "function" ? e : Ai(e), o = t == null ? es : typeof t == "function" ? t : go(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
  });
}
function ns() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function os() {
  return this.each(ns);
}
function is() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function rs() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function as(e) {
  return this.select(e ? rs : is);
}
function ls(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function ss(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function us(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", o = t.indexOf(".");
    return o >= 0 && (n = t.slice(o + 1), t = t.slice(0, o)), { type: t, name: n };
  });
}
function cs(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, o = -1, i = t.length, r; n < i; ++n)
        r = t[n], (!e.type || r.type === e.type) && r.name === e.name ? this.removeEventListener(r.type, r.listener, r.options) : t[++o] = r;
      ++o ? t.length = o : delete this.__on;
    }
  };
}
function ds(e, t, n) {
  return function() {
    var o = this.__on, i, r = ss(t);
    if (o) {
      for (var a = 0, l = o.length; a < l; ++a)
        if ((i = o[a]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = r, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, r, n), i = { type: e.type, name: e.name, value: t, listener: r, options: n }, o ? o.push(i) : this.__on = [i];
  };
}
function fs(e, t, n) {
  var o = us(e + ""), i, r = o.length, a;
  if (arguments.length < 2) {
    var l = this.node().__on;
    if (l) {
      for (var s = 0, u = l.length, c; s < u; ++s)
        for (i = 0, c = l[s]; i < r; ++i)
          if ((a = o[i]).type === c.type && a.name === c.name)
            return c.value;
    }
    return;
  }
  for (l = t ? ds : cs, i = 0; i < r; ++i)
    this.each(l(o[i], t, n));
  return this;
}
function Ui(e, t, n) {
  var o = Li(e), i = o.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = o.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function hs(e, t) {
  return function() {
    return Ui(this, e, t);
  };
}
function gs(e, t) {
  return function() {
    return Ui(this, e, t.apply(this, arguments));
  };
}
function vs(e, t) {
  return this.each((typeof t == "function" ? gs : hs)(e, t));
}
function* ps() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], i = 0, r = o.length, a; i < r; ++i)
      (a = o[i]) && (yield a);
}
var Zi = [null];
function xe(e, t) {
  this._groups = e, this._parents = t;
}
function Mt() {
  return new xe([[document.documentElement]], Zi);
}
function ms() {
  return this;
}
xe.prototype = Mt.prototype = {
  constructor: xe,
  select: Ga,
  selectAll: Za,
  selectChild: ja,
  selectChildren: tl,
  filter: nl,
  data: sl,
  enter: ol,
  exit: cl,
  join: dl,
  merge: fl,
  selection: ms,
  order: hl,
  sort: gl,
  call: pl,
  nodes: ml,
  node: yl,
  size: xl,
  empty: _l,
  each: wl,
  attr: $l,
  style: Tl,
  property: Al,
  classed: Hl,
  text: Yl,
  html: Kl,
  raise: ql,
  lower: Ql,
  append: Jl,
  insert: ts,
  remove: os,
  clone: as,
  datum: ls,
  on: fs,
  dispatch: vs,
  [Symbol.iterator]: ps
};
function _e(e) {
  return typeof e == "string" ? new xe([[document.querySelector(e)]], [document.documentElement]) : new xe([[e]], Zi);
}
function ys(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function Se(e, t) {
  if (e = ys(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var o = n.createSVGPoint();
      return o.x = e.clientX, o.y = e.clientY, o = o.matrixTransform(t.getScreenCTM().inverse()), [o.x, o.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const xs = { passive: !1 }, bt = { capture: !0, passive: !1 };
function Nn(e) {
  e.stopImmediatePropagation();
}
function it(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Ki(e) {
  var t = e.document.documentElement, n = _e(e).on("dragstart.drag", it, bt);
  "onselectstart" in t ? n.on("selectstart.drag", it, bt) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Wi(e, t) {
  var n = e.document.documentElement, o = _e(e).on("dragstart.drag", null);
  t && (o.on("click.drag", it, bt), setTimeout(function() {
    o.on("click.drag", null);
  }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const Ot = (e) => () => e;
function Xn(e, {
  sourceEvent: t,
  subject: n,
  target: o,
  identifier: i,
  active: r,
  x: a,
  y: l,
  dx: s,
  dy: u,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: r, enumerable: !0, configurable: !0 },
    x: { value: a, enumerable: !0, configurable: !0 },
    y: { value: l, enumerable: !0, configurable: !0 },
    dx: { value: s, enumerable: !0, configurable: !0 },
    dy: { value: u, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
Xn.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function _s(e) {
  return !e.ctrlKey && !e.button;
}
function ws() {
  return this.parentNode;
}
function bs(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function Es() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Ss() {
  var e = _s, t = ws, n = bs, o = Es, i = {}, r = cn("start", "drag", "end"), a = 0, l, s, u, c, g = 0;
  function v(x) {
    x.on("mousedown.drag", w).filter(o).on("touchstart.drag", _).on("touchmove.drag", y, xs).on("touchend.drag touchcancel.drag", S).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function w(x, C) {
    if (!(c || !e.call(this, x, C))) {
      var T = A(this, t.call(this, x, C), x, C, "mouse");
      T && (_e(x.view).on("mousemove.drag", f, bt).on("mouseup.drag", d, bt), Ki(x.view), Nn(x), u = !1, l = x.clientX, s = x.clientY, T("start", x));
    }
  }
  function f(x) {
    if (it(x), !u) {
      var C = x.clientX - l, T = x.clientY - s;
      u = C * C + T * T > g;
    }
    i.mouse("drag", x);
  }
  function d(x) {
    _e(x.view).on("mousemove.drag mouseup.drag", null), Wi(x.view, u), it(x), i.mouse("end", x);
  }
  function _(x, C) {
    if (e.call(this, x, C)) {
      var T = x.changedTouches, p = t.call(this, x, C), G = T.length, R, I;
      for (R = 0; R < G; ++R)
        (I = A(this, p, x, C, T[R].identifier, T[R])) && (Nn(x), I("start", x, T[R]));
    }
  }
  function y(x) {
    var C = x.changedTouches, T = C.length, p, G;
    for (p = 0; p < T; ++p)
      (G = i[C[p].identifier]) && (it(x), G("drag", x, C[p]));
  }
  function S(x) {
    var C = x.changedTouches, T = C.length, p, G;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), p = 0; p < T; ++p)
      (G = i[C[p].identifier]) && (Nn(x), G("end", x, C[p]));
  }
  function A(x, C, T, p, G, R) {
    var I = r.copy(), H = Se(R || T, C), te, q, m;
    if ((m = n.call(x, new Xn("beforestart", {
      sourceEvent: T,
      target: v,
      identifier: G,
      active: a,
      x: H[0],
      y: H[1],
      dx: 0,
      dy: 0,
      dispatch: I
    }), p)) != null)
      return te = m.x - H[0] || 0, q = m.y - H[1] || 0, function L($, P, K) {
        var Y = H, D;
        switch ($) {
          case "start":
            i[G] = L, D = a++;
            break;
          case "end":
            delete i[G], --a;
          case "drag":
            H = Se(K || P, C), D = a;
            break;
        }
        I.call(
          $,
          x,
          new Xn($, {
            sourceEvent: P,
            subject: m,
            target: v,
            identifier: G,
            active: D,
            x: H[0] + te,
            y: H[1] + q,
            dx: H[0] - Y[0],
            dy: H[1] - Y[1],
            dispatch: I
          }),
          p
        );
      };
  }
  return v.filter = function(x) {
    return arguments.length ? (e = typeof x == "function" ? x : Ot(!!x), v) : e;
  }, v.container = function(x) {
    return arguments.length ? (t = typeof x == "function" ? x : Ot(x), v) : t;
  }, v.subject = function(x) {
    return arguments.length ? (n = typeof x == "function" ? x : Ot(x), v) : n;
  }, v.touchable = function(x) {
    return arguments.length ? (o = typeof x == "function" ? x : Ot(!!x), v) : o;
  }, v.on = function() {
    var x = r.on.apply(r, arguments);
    return x === r ? v : x;
  }, v.clickDistance = function(x) {
    return arguments.length ? (g = (x = +x) * x, v) : Math.sqrt(g);
  }, v;
}
function qi(e) {
  const t = fi();
  return ht(() => t.stop()), t.run(() => {
    const n = ce(), o = E(n, "vueFlowRef"), i = E(n, "snapToGrid"), r = E(n, "snapGrid"), a = E(n, "noDragClassName"), l = E(n, "nodes"), s = E(n, "nodeExtent"), u = E(n, "viewport"), c = E(n, "autoPanOnNodeDrag"), g = E(n, "nodesDraggable"), v = E(n, "panBy"), w = E(n, "findNode"), f = E(n, "multiSelectionActive"), d = E(n, "nodesSelectionActive"), _ = E(n, "selectNodesOnDrag"), y = E(n, "removeSelectedElements"), S = E(n, "addSelectedNodes"), A = E(n, "updateNodePositions"), x = E(n, "emits"), C = e, T = E(C, "onStart"), p = E(C, "onDrag"), G = E(C, "onStop"), R = E(C, "el"), I = E(C, "disabled"), H = E(C, "id"), te = E(C, "selectable"), q = ne(!1);
    let m = ne([]), L = ne(), $ = ne(null), P = ne({ x: void 0, y: void 0 }), K = ne({ x: 0, y: 0 }), Y = ne(null), D = ne(0), U = ne(!1);
    const j = W(() => H.value ? w.value(H.value) : void 0), ie = Aa();
    return ue([() => I.value, () => R.value], () => {
      if (R.value) {
        const re = _e(R.value), B = ({ x: F, y: h }) => {
          P.value = { x: F, y: h };
          let b = !1;
          if (m.value = m.value.map((z) => {
            const O = { x: F - z.distance.x, y: h - z.distance.y };
            i.value && (O.x = r.value[0] * Math.round(O.x / r.value[0]), O.y = r.value[1] * Math.round(O.y / r.value[1]));
            const { computedPosition: V } = ho(
              z,
              O,
              x.value.error,
              s.value,
              z.parentNode ? w.value(z.parentNode) : void 0
            );
            return b = b || z.position.x !== V.x || z.position.y !== V.y, z.position = V, z;
          }), !!b && (A.value(m.value, !0, !0), q.value = !0, Y.value)) {
            const [z, O] = Sn({
              id: H.value,
              dragItems: m.value,
              findNode: w.value
            });
            p.value(Y.value, z, O);
          }
        }, k = () => {
          if (!$.value)
            return;
          const [F, h] = Pi(K.value, $.value);
          (F !== 0 || h !== 0) && (P.value.x = (P.value.x ?? 0) - F / u.value.zoom, P.value.y = (P.value.y ?? 0) - h / u.value.zoom, B(P.value), v.value({ x: F, y: h })), D.value = requestAnimationFrame(k);
        };
        I.value ? re.on(".drag", null) : (L.value = Ss().on("start", (F) => {
          var b, z;
          !_.value && !f.value && H.value && ((b = j.value) != null && b.selected || y.value()), j.value && te.value && _.value && Gn(
            j.value,
            f.value,
            S.value,
            y.value,
            d,
            !1,
            R.value
          );
          const h = ie(F);
          if (P.value = h, m.value = Ia(l.value, g.value, h, w.value, H.value), m.value.length) {
            const [O, V] = Sn({
              id: H.value,
              dragItems: m.value,
              findNode: w.value
            });
            T.value(F.sourceEvent, O, V);
          }
          $.value = ((z = o.value) == null ? void 0 : z.getBoundingClientRect()) || null, K.value = ot(F.sourceEvent, $.value);
        }).on("drag", (F) => {
          const h = ie(F);
          !U.value && c.value && (U.value = !0, k()), (P.value.x !== h.xSnapped || P.value.y !== h.ySnapped) && m.value.length && (Y.value = F.sourceEvent, K.value = ot(F.sourceEvent, $.value), B(h));
        }).on("end", (F) => {
          if (q.value = !1, U.value = !1, cancelAnimationFrame(D.value), m.value.length) {
            A.value(m.value, !1, !1);
            const [h, b] = Sn({
              id: H.value,
              dragItems: m.value,
              findNode: w.value
            });
            G.value(F.sourceEvent, h, b);
          }
        }).filter((F) => {
          var b;
          const h = F.target;
          return !F.button && (!a.value || !Ro(h, `.${a.value}`, R.value) && (!((b = j.value) != null && b.dragHandle) || Ro(h, j.value.dragHandle, R.value)));
        }), re.call(L.value));
      }
    }), q;
  });
}
const ji = "vue-flow__node-desc", Qi = "vue-flow__edge-desc", Ns = "vue-flow__aria-live", Ji = ["Enter", " ", "Escape"], rt = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
function Un(e) {
  var i, r;
  const t = ((r = (i = e.composedPath) == null ? void 0 : i.call(e)) == null ? void 0 : r[0]) || e.target, n = Pe(t.hasAttribute) ? t.hasAttribute("contenteditable") : !1, o = Pe(t.closest) ? t.closest(".nokey") : null;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(t == null ? void 0 : t.nodeName) || n || !!o;
}
function Cs(e) {
  return e.ctrlKey || e.metaKey || e.shiftKey;
}
function Ms(e, t) {
  return (n) => e.some((o) => {
    const i = o.split("+").map((r) => r.trim().toLowerCase());
    return i.length === 1 ? n.key === o : (t.add(n.key.toLowerCase()), i.every((r) => t.has(r)));
  });
}
const _t = (e, t) => {
  const n = io();
  let o = ne(M(e) === !0), i = ne(!1);
  const r = ne(/* @__PURE__ */ new Set());
  return ue(o, () => {
    t && typeof t == "function" && t(o.value);
  }), An(() => {
    let a = M(e);
    if (typeof n.addEventListener < "u" && oo(n, "blur", () => {
      o.value = !1;
    }), Pr(a)) {
      o.value = a;
      return;
    }
    Array.isArray(a) && (a = Ms(a, r.value)), a && (No(
      a,
      (l) => {
        i.value = Cs(l), !(!i.value && Un(l)) && (l.preventDefault(), o.value = !0);
      },
      { eventName: "keydown" }
    ), No(
      a,
      (l) => {
        if (o.value) {
          if (!i.value && Un(l))
            return;
          i.value = !1, r.value.clear(), o.value = !1;
        }
      },
      { eventName: "keyup" }
    ));
  }), o;
}, $s = ge({
  name: "Node",
  compatConfig: { MODE: 3 },
  props: ["name", "type", "id", "draggable", "selectable", "focusable", "connectable", "node", "resizeObserver"],
  setup(e) {
    lt($i, e.id);
    const t = ce(), n = E(t, "id"), o = E(t, "edges"), i = E(t, "noPanClassName"), r = E(t, "selectNodesOnDrag"), a = E(t, "nodesSelectionActive"), l = E(t, "multiSelectionActive"), s = E(t, "emits"), u = E(t, "findNode"), c = E(t, "removeSelectedNodes"), g = E(t, "addSelectedNodes"), v = E(t, "updateNodeDimensions"), w = E(t, "onUpdateNodeInternals"), f = E(t, "getIntersectingNodes"), d = E(t, "getNodeTypes"), _ = E(t, "nodeExtent"), y = E(t, "elevateNodesOnSelect"), S = E(t, "disableKeyboardA11y"), A = E(t, "ariaLiveMessage"), x = E(t, "snapToGrid"), C = E(t, "snapGrid"), T = zi(), p = xt(e, "node"), G = W(() => p.value.parentNode ? u.value(p.value.parentNode) : void 0), R = W(() => rn([p.value], o.value)), I = ne();
    lt(ki, I);
    const { emit: H, on: te } = za(p.value, s.value), q = qi({
      id: e.id,
      el: I,
      disabled: W(() => !e.draggable),
      selectable: W(() => e.selectable),
      onStart(k, F, h) {
        H.dragStart({ event: k, node: F, nodes: h, intersections: f.value(F) });
      },
      onDrag(k, F, h) {
        H.drag({ event: k, node: F, nodes: h, intersections: f.value(F) });
      },
      onStop(k, F, h) {
        H.dragStop({ event: k, node: F, nodes: h, intersections: f.value(F) });
      }
    }), m = W(() => p.value.class instanceof Function ? p.value.class(p.value) : p.value.class), L = W(() => {
      const k = (p.value.style instanceof Function ? p.value.style(p.value) : p.value.style) || {}, F = p.value.width instanceof Function ? p.value.width(p.value) : p.value.width, h = p.value.height instanceof Function ? p.value.height(p.value) : p.value.height;
      return F && (k.width = typeof F == "string" ? F : `${F}px`), h && (k.height = typeof h == "string" ? h : `${h}px`), k;
    }), $ = W(() => Number(p.value.zIndex ?? L.value.zIndex ?? 0));
    return w.value((k) => {
      k.includes(e.id) && K();
    }), Ve(() => {
      e.resizeObserver.observe(I.value);
    }), hi(() => {
      e.resizeObserver.unobserve(I.value);
    }), ue(
      [() => p.value.type, () => p.value.sourcePosition, () => p.value.targetPosition],
      () => {
        v.value([{ id: e.id, nodeElement: I.value, forceUpdate: !0 }]);
      },
      { flush: "pre" }
    ), ue(
      [
        () => p.value.position.x,
        () => p.value.position.y,
        () => {
          var k;
          return (k = G.value) == null ? void 0 : k.computedPosition.x;
        },
        () => {
          var k;
          return (k = G.value) == null ? void 0 : k.computedPosition.y;
        },
        () => {
          var k;
          return (k = G.value) == null ? void 0 : k.computedPosition.z;
        },
        () => p.value.selected,
        () => p.value.dimensions.height,
        () => p.value.dimensions.width,
        () => {
          var k;
          return (k = G.value) == null ? void 0 : k.dimensions.height;
        },
        () => {
          var k;
          return (k = G.value) == null ? void 0 : k.dimensions.width;
        },
        $
      ],
      ([k, F, h, b, z]) => {
        const O = {
          x: k,
          y: F,
          z: $.value + (y.value && p.value.selected ? 1e3 : 0)
        };
        Ie(h) && Ie(b) ? p.value.computedPosition = ha({ x: h, y: b, z }, O) : p.value.computedPosition = O;
      },
      { flush: "pre", immediate: !0 }
    ), ue([() => p.value.extent, () => _.value], ([k, F], [h, b]) => {
      (k !== h || F !== b) && P();
    }), p.value.extent === "parent" || typeof p.value.extent == "object" && "range" in p.value.extent && p.value.extent.range === "parent" ? pe(() => p.value.initialized).toBe(!0).then(P) : P(), () => le(
      "div",
      {
        ref: I,
        "data-id": p.value.id,
        class: [
          "vue-flow__node",
          `vue-flow__node-${e.type === !1 ? "default" : e.name}`,
          {
            [i.value]: e.draggable,
            dragging: q == null ? void 0 : q.value,
            selected: p.value.selected,
            selectable: e.selectable
          },
          m.value
        ],
        style: {
          zIndex: p.value.computedPosition.z ?? $.value,
          transform: `translate(${p.value.computedPosition.x}px,${p.value.computedPosition.y}px)`,
          pointerEvents: e.selectable || e.draggable ? "all" : "none",
          visibility: p.value.initialized ? "visible" : "hidden",
          ...L.value
        },
        tabIndex: e.focusable ? 0 : void 0,
        role: e.focusable ? "button" : void 0,
        "aria-describedby": S.value ? void 0 : `${ji}-${n.value}`,
        "aria-label": p.value.ariaLabel,
        onMouseenter: Y,
        onMousemove: D,
        onMouseleave: U,
        onContextmenu: j,
        onClick: re,
        onDblclick: ie,
        onKeydown: B
      },
      [
        le(e.type === !1 ? d.value.default : e.type, {
          id: p.value.id,
          type: p.value.type,
          data: p.value.data,
          events: { ...p.value.events, ...te },
          selected: !!p.value.selected,
          resizing: !!p.value.resizing,
          dragging: q == null ? void 0 : q.value,
          connectable: e.connectable,
          position: p.value.position,
          dimensions: p.value.dimensions,
          isValidTargetPos: p.value.isValidTargetPos,
          isValidSourcePos: p.value.isValidSourcePos,
          parent: p.value.parentNode,
          zIndex: p.value.computedPosition.z,
          targetPosition: p.value.targetPosition,
          sourcePosition: p.value.sourcePosition,
          label: p.value.label,
          dragHandle: p.value.dragHandle,
          onUpdateNodeInternals: K
        })
      ]
    );
    function P() {
      const k = p.value.computedPosition;
      x.value && (k.x = C.value[0] * Math.round(k.x / C.value[0]), k.y = C.value[1] * Math.round(k.y / C.value[1]));
      const { computedPosition: F, position: h } = ho(p.value, k, s.value.error, _.value, G.value);
      (p.value.computedPosition.x !== F.x || p.value.computedPosition.y !== F.y) && (p.value.computedPosition = { ...p.value.computedPosition, ...F }), (p.value.position.x !== h.x || p.value.position.y !== h.y) && (p.value.position = h);
    }
    function K() {
      I.value && v.value([{ id: e.id, nodeElement: I.value, forceUpdate: !0 }]);
    }
    function Y(k) {
      q != null && q.value || H.mouseEnter({ event: k, node: p.value, connectedEdges: R.value });
    }
    function D(k) {
      q != null && q.value || H.mouseMove({ event: k, node: p.value, connectedEdges: R.value });
    }
    function U(k) {
      q != null && q.value || H.mouseLeave({ event: k, node: p.value, connectedEdges: R.value });
    }
    function j(k) {
      return H.contextMenu({ event: k, node: p.value, connectedEdges: R.value });
    }
    function ie(k) {
      return H.doubleClick({ event: k, node: p.value, connectedEdges: R.value });
    }
    function re(k) {
      e.selectable && (!r.value || !e.draggable) && Gn(
        p.value,
        l.value,
        g.value,
        c.value,
        a,
        !1,
        I.value
      ), H.click({ event: k, node: p.value, connectedEdges: R.value });
    }
    function B(k) {
      var F;
      if (!Un(k))
        if (Ji.includes(k.key) && e.selectable) {
          const h = k.key === "Escape";
          h && ((F = I.value) == null || F.blur()), Gn(
            p.value,
            l.value,
            g.value,
            c.value,
            a,
            h,
            I.value
          );
        } else
          !S.value && e.draggable && p.value.selected && rt[k.key] && (A.value = `Moved selected node ${k.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~p.value.position.x}, y: ${~~p.value.position.y}`, T(
            {
              x: rt[k.key].x,
              y: rt[k.key].y
            },
            k.shiftKey
          ));
    }
  }
}), ks = $s, Is = ["transform"], Os = ["width", "height", "x", "y", "rx", "ry"], Ts = ["y"], Ps = {
  name: "EdgeText",
  compatConfig: { MODE: 3 }
}, Ds = /* @__PURE__ */ ge({
  ...Ps,
  props: {
    x: null,
    y: null,
    label: null,
    labelStyle: { default: {} },
    labelShowBg: { type: Boolean, default: !0 },
    labelBgStyle: { default: {} },
    labelBgPadding: { default: [2, 4] },
    labelBgBorderRadius: { default: 2 }
  },
  setup(e) {
    let t = ne({ x: 0, y: 0, width: 0, height: 0 });
    const n = ne(null), o = W(() => `translate(${e.x - t.value.width / 2} ${e.y - t.value.height / 2})`);
    Ve(i), ue([() => e.x, () => e.y, n, () => e.label], i);
    function i() {
      if (!n.value)
        return;
      const r = n.value.getBBox();
      (r.width !== t.value.width || r.height !== t.value.height) && (t.value = r);
    }
    return (r, a) => (oe(), ae("g", {
      transform: M(o),
      class: "vue-flow__edge-textwrapper"
    }, [
      e.labelShowBg ? (oe(), ae("rect", {
        key: 0,
        class: "vue-flow__edge-textbg",
        width: `${M(t).width + 2 * e.labelBgPadding[0]}px`,
        height: `${M(t).height + 2 * e.labelBgPadding[1]}px`,
        x: -e.labelBgPadding[0],
        y: -e.labelBgPadding[1],
        style: Le(e.labelBgStyle),
        rx: e.labelBgBorderRadius,
        ry: e.labelBgBorderRadius
      }, null, 12, Os)) : be("", !0),
      st("text", gi(r.$attrs, {
        ref_key: "el",
        ref: n,
        class: "vue-flow__edge-text",
        y: M(t).height / 2,
        dy: "0.3em",
        style: e.labelStyle
      }), [
        ye(r.$slots, "default", {}, () => [
          M(Be)(e.label) ? (oe(), ae(Ne, { key: 1 }, [
            Nr(Bn(e.label), 1)
          ], 64)) : (oe(), Te(vi(e.label), { key: 0 }))
        ])
      ], 16, Ts)
    ], 8, Is));
  }
}), fn = function({
  path: e,
  label: t,
  labelX: n,
  labelY: o,
  labelBgBorderRadius: i,
  labelBgPadding: r,
  labelBgStyle: a,
  labelShowBg: l = !0,
  labelStyle: s,
  markerStart: u,
  markerEnd: c,
  interactionWidth: g = 20
}, { attrs: v }) {
  return [
    le("path", {
      style: v.style,
      class: ["vue-flow__edge-path", v.class].join(" "),
      d: e,
      "marker-end": c,
      "marker-start": u
    }),
    g ? le("path", {
      d: e,
      fill: "none",
      "stroke-opacity": 0,
      "stroke-width": g
    }) : null,
    t && Ie(n) && Ie(o) ? le(Ds, {
      x: n,
      y: o,
      label: t,
      labelStyle: s,
      labelShowBg: l,
      labelBgStyle: a,
      labelBgPadding: r,
      labelBgBorderRadius: i
    }) : null
  ];
};
fn.props = [
  "path",
  "labelX",
  "labelY",
  "label",
  "labelBgBorderRadius",
  "labelBgPadding",
  "labelBgStyle",
  "labelShowBg",
  "labelStyle",
  "markerStart",
  "markerEnd",
  "interactionWidth"
];
fn.inheritAttrs = !1;
fn.compatConfig = { MODE: 3 };
const hn = fn;
function er({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const i = Math.abs(n - e) / 2, r = n < e ? n + i : n - i, a = Math.abs(o - t) / 2, l = o < t ? o + a : o - a;
  return [r, l, i, a];
}
function tr({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o,
  sourceControlX: i,
  sourceControlY: r,
  targetControlX: a,
  targetControlY: l
}) {
  const s = e * 0.125 + i * 0.375 + a * 0.375 + n * 0.125, u = t * 0.125 + r * 0.375 + l * 0.375 + o * 0.125, c = Math.abs(s - e), g = Math.abs(u - t);
  return [s, u, c, g];
}
function Tt(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function Fo({ pos: e, x1: t, y1: n, x2: o, y2: i, c: r }) {
  let a, l;
  switch (e) {
    case J.Left:
      a = t - Tt(t - o, r), l = n;
      break;
    case J.Right:
      a = t + Tt(o - t, r), l = n;
      break;
    case J.Top:
      a = t, l = n - Tt(n - i, r);
      break;
    case J.Bottom:
      a = t, l = n + Tt(i - n, r);
      break;
  }
  return [a, l];
}
function Zn({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = J.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = J.Top,
  curvature: a = 0.25
}) {
  const [l, s] = Fo({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i,
    c: a
  }), [u, c] = Fo({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t,
    c: a
  }), [g, v, w, f] = tr({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: l,
    sourceControlY: s,
    targetControlX: u,
    targetControlY: c
  });
  return [
    `M${e},${t} C${l},${s} ${u},${c} ${o},${i}`,
    g,
    v,
    w,
    f
  ];
}
const gn = function({ sourcePosition: e = J.Bottom, targetPosition: t = J.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Zn({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return le(hn, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
gn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "curvature",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
gn.inheritAttrs = !1;
gn.compatConfig = { MODE: 3 };
const zs = gn;
function Go({ pos: e, x1: t, y1: n, x2: o, y2: i }) {
  let r, a;
  switch (e) {
    case J.Left:
    case J.Right:
      r = 0.5 * (t + o), a = n;
      break;
    case J.Top:
    case J.Bottom:
      r = t, a = 0.5 * (n + i);
      break;
  }
  return [r, a];
}
function nr({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = J.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = J.Top
}) {
  const [a, l] = Go({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: i
  }), [s, u] = Go({
    pos: r,
    x1: o,
    y1: i,
    x2: e,
    y2: t
  }), [c, g, v, w] = tr({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: i,
    sourceControlX: a,
    sourceControlY: l,
    targetControlX: s,
    targetControlY: u
  });
  return [
    `M${e},${t} C${a},${l} ${s},${u} ${o},${i}`,
    c,
    g,
    v,
    w
  ];
}
const vn = function({ sourcePosition: e = J.Bottom, targetPosition: t = J.Top, ...n }, { attrs: o }) {
  const [i, r, a] = nr({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return le(hn, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
vn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
vn.inheritAttrs = !1;
vn.compatConfig = { MODE: 3 };
const As = vn, Yo = {
  [J.Left]: { x: -1, y: 0 },
  [J.Right]: { x: 1, y: 0 },
  [J.Top]: { x: 0, y: -1 },
  [J.Bottom]: { x: 0, y: 1 }
};
function Bs({
  source: e,
  sourcePosition: t = J.Bottom,
  target: n
}) {
  return t === J.Left || t === J.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 };
}
function Xo(e, t) {
  return Math.sqrt((t.x - e.x) ** 2 + (t.y - e.y) ** 2);
}
function Rs({
  source: e,
  sourcePosition: t = J.Bottom,
  target: n,
  targetPosition: o = J.Top,
  center: i,
  offset: r
}) {
  const a = Yo[t], l = Yo[o], s = { x: e.x + a.x * r, y: e.y + a.y * r }, u = { x: n.x + l.x * r, y: n.y + l.y * r }, c = Bs({
    source: s,
    sourcePosition: t,
    target: u
  }), g = c.x !== 0 ? "x" : "y", v = c[g];
  let w, f, d;
  const [_, y, S, A] = er({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (a[g] * l[g] === -1) {
    f = i.x || _, d = i.y || y;
    const C = [
      { x: f, y: s.y },
      { x: f, y: u.y }
    ], T = [
      { x: s.x, y: d },
      { x: u.x, y: d }
    ];
    a[g] === v ? w = g === "x" ? C : T : w = g === "x" ? T : C;
  } else {
    const C = [{ x: s.x, y: u.y }], T = [{ x: u.x, y: s.y }];
    if (g === "x" ? w = a.x === v ? T : C : w = a.y === v ? C : T, t !== o) {
      const p = g === "x" ? "y" : "x", G = a[g] === l[p], R = s[p] > u[p], I = s[p] < u[p];
      (a[g] === 1 && (!G && R || G && I) || a[g] !== 1 && (!G && I || G && R)) && (w = g === "x" ? C : T);
    }
    f = w[0].x, d = w[0].y;
  }
  return [[e, s, ...w, u, n], f, d, S, A];
}
function Vs(e, t, n, o) {
  const i = Math.min(Xo(e, t) / 2, Xo(t, n) / 2, o), { x: r, y: a } = t;
  if (e.x === r && r === n.x || e.y === a && a === n.y)
    return `L${r} ${a}`;
  if (e.y === a) {
    const u = e.x < n.x ? -1 : 1, c = e.y < n.y ? 1 : -1;
    return `L ${r + i * u},${a}Q ${r},${a} ${r},${a + i * c}`;
  }
  const l = e.x < n.x ? 1 : -1, s = e.y < n.y ? -1 : 1;
  return `L ${r},${a + i * s}Q ${r},${a} ${r + i * l},${a}`;
}
function Kn({
  sourceX: e,
  sourceY: t,
  sourcePosition: n = J.Bottom,
  targetX: o,
  targetY: i,
  targetPosition: r = J.Top,
  borderRadius: a = 5,
  centerX: l,
  centerY: s,
  offset: u = 20
}) {
  const [c, g, v, w, f] = Rs({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: o, y: i },
    targetPosition: r,
    center: { x: l, y: s },
    offset: u
  });
  return [c.reduce((_, y, S) => {
    let A;
    return S > 0 && S < c.length - 1 ? A = Vs(c[S - 1], y, c[S + 1], a) : A = `${S === 0 ? "M" : "L"}${y.x} ${y.y}`, _ += A, _;
  }, ""), g, v, w, f];
}
const pn = function({ sourcePosition: e = J.Bottom, targetPosition: t = J.Top, ...n }, { attrs: o }) {
  const [i, r, a] = Kn({
    sourcePosition: e,
    targetPosition: t,
    ...n
  });
  return le(hn, {
    path: i,
    labelX: r,
    labelY: a,
    ...n,
    ...o
  });
};
pn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "borderRadius",
  "markerEnd",
  "markerStart",
  "interactionWidth",
  "offset"
];
pn.inheritAttrs = !1;
pn.compatConfig = { MODE: 3 };
const or = pn, mn = function(e, { attrs: t }) {
  return le(or, { ...e, ...t, borderRadius: 0 });
};
mn.props = [
  "sourcePosition",
  "targetPosition",
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
mn.inheritAttrs = !1;
mn.compatConfig = { MODE: 3 };
const Hs = mn;
function ir({
  sourceX: e,
  sourceY: t,
  targetX: n,
  targetY: o
}) {
  const [i, r, a, l] = er({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: o
  });
  return [`M ${e},${t}L ${n},${o}`, i, r, a, l];
}
const yn = function(e, { attrs: t }) {
  const [n, o, i] = ir(e);
  return le(hn, {
    path: n,
    labelX: o,
    labelY: i,
    ...e,
    ...t
  });
};
yn.props = [
  "label",
  "labelStyle",
  "labelShowBg",
  "labelBgStyle",
  "labelBgPadding",
  "labelBgBorderRadius",
  "sourceY",
  "sourceX",
  "targetX",
  "targetY",
  "markerEnd",
  "markerStart",
  "interactionWidth"
];
yn.inheritAttrs = !1;
yn.compatConfig = { MODE: 3 };
const Ls = yn;
function Fs(e, t, n) {
  return n === J.Left ? e - t : n === J.Right ? e + t : e;
}
function Gs(e, t, n) {
  return n === J.Top ? e - t : n === J.Bottom ? e + t : e;
}
const po = function({
  radius: e = 10,
  centerX: t = 0,
  centerY: n = 0,
  position: o = J.Top,
  type: i
}) {
  return le("circle", {
    class: `vue-flow__edgeupdater vue-flow__edgeupdater-${i}`,
    cx: Fs(t, e, o),
    cy: Gs(n, e, o),
    r: e,
    stroke: "transparent",
    fill: "transparent"
  });
};
po.props = ["radius", "centerX", "centerY", "position", "type"];
po.compatConfig = { MODE: 3 };
const Uo = po;
function Ys() {
  return {
    doubleClick: X(),
    click: X(),
    mouseEnter: X(),
    mouseMove: X(),
    mouseLeave: X(),
    contextMenu: X(),
    updateStart: X(),
    update: X(),
    updateEnd: X()
  };
}
function Xs(e, t) {
  const n = Ys();
  return n.doubleClick.on((o) => {
    var i, r;
    t.edgeDoubleClick(o), (r = (i = e.events) == null ? void 0 : i.doubleClick) == null || r.call(i, o);
  }), n.click.on((o) => {
    var i, r;
    t.edgeClick(o), (r = (i = e.events) == null ? void 0 : i.click) == null || r.call(i, o);
  }), n.mouseEnter.on((o) => {
    var i, r;
    t.edgeMouseEnter(o), (r = (i = e.events) == null ? void 0 : i.mouseEnter) == null || r.call(i, o);
  }), n.mouseMove.on((o) => {
    var i, r;
    t.edgeMouseMove(o), (r = (i = e.events) == null ? void 0 : i.mouseMove) == null || r.call(i, o);
  }), n.mouseLeave.on((o) => {
    var i, r;
    t.edgeMouseLeave(o), (r = (i = e.events) == null ? void 0 : i.mouseLeave) == null || r.call(i, o);
  }), n.contextMenu.on((o) => {
    var i, r;
    t.edgeContextMenu(o), (r = (i = e.events) == null ? void 0 : i.contextMenu) == null || r.call(i, o);
  }), n.updateStart.on((o) => {
    var i, r;
    t.edgeUpdateStart(o), (r = (i = e.events) == null ? void 0 : i.updateStart) == null || r.call(i, o);
  }), n.update.on((o) => {
    var i, r;
    t.edgeUpdate(o), (r = (i = e.events) == null ? void 0 : i.update) == null || r.call(i, o);
  }), n.updateEnd.on((o) => {
    var i, r;
    t.edgeUpdateEnd(o), (r = (i = e.events) == null ? void 0 : i.updateEnd) == null || r.call(i, o);
  }), Object.entries(n).reduce(
    (o, [i, r]) => (o.emit[i] = r.trigger, o.on[i] = r.on, o),
    { emit: {}, on: {} }
  );
}
const Us = ge({
  name: "Edge",
  compatConfig: { MODE: 3 },
  props: ["name", "type", "id", "updatable", "selectable", "focusable", "edge"],
  setup(e) {
    const {
      id: t,
      addSelectedEdges: n,
      connectionMode: o,
      edgeUpdaterRadius: i,
      emits: r,
      nodesSelectionActive: a,
      noPanClassName: l,
      getEdgeTypes: s,
      removeSelectedEdges: u,
      findEdge: c,
      findNode: g,
      isValidConnection: v
    } = ce(), w = Xs(e.edge, r), f = xt(e, "edge");
    let d = ne(!1), _ = ne(!1);
    const y = ne(""), S = ne(null), A = ne("source"), x = ne("source"), C = ne();
    lt(Ii, e.id), lt(Oi, C);
    const T = W(() => g(f.value.source)), p = W(() => g(f.value.target)), G = W(() => f.value.class instanceof Function ? f.value.class(f.value) : f.value.class), R = W(() => f.value.style instanceof Function ? f.value.style(f.value) : f.value.style), { handlePointerDown: I } = Di({
      nodeId: y,
      handleId: S,
      type: A,
      isValidConnection: v.value,
      edgeUpdaterType: x,
      onEdgeUpdate: q,
      onEdgeUpdateEnd: m
    });
    return () => {
      if (!T.value || !p.value || !f.value)
        return null;
      let B;
      o.value === Qe.Strict ? B = T.value.handleBounds.source : B = [...T.value.handleBounds.source || [], ...T.value.handleBounds.target || []];
      const k = Do(B, f.value.sourceHandle);
      let F;
      o.value === Qe.Strict ? F = p.value.handleBounds.target : F = [...p.value.handleBounds.target || [], ...p.value.handleBounds.source || []];
      const h = Do(F, f.value.targetHandle), b = k ? k.position : J.Bottom, z = h ? h.position : J.Top, { sourceX: O, sourceY: V, targetY: Z, targetX: N } = ya(
        T.value,
        k,
        b,
        p.value,
        h,
        z
      );
      return f.value.sourceX = O, f.value.sourceY = V, f.value.targetX = N, f.value.targetY = Z, le(
        "g",
        {
          ref: C,
          key: e.id,
          "data-id": e.id,
          class: [
            "vue-flow__edge",
            `vue-flow__edge-${e.type === !1 ? "default" : e.name}`,
            l.value,
            G.value,
            {
              updating: d.value,
              selected: f.value.selected,
              animated: f.value.animated,
              inactive: !e.selectable
            }
          ],
          onClick: $,
          onContextmenu: P,
          onDblclick: K,
          onMouseenter: Y,
          onMousemove: D,
          onMouseleave: U,
          onKeyDown: e.focusable ? re : void 0,
          tabIndex: e.focusable ? 0 : void 0,
          "aria-label": f.value.ariaLabel === null ? void 0 : f.value.ariaLabel || `Edge from ${f.value.source} to ${f.value.target}`,
          "aria-describedby": e.focusable ? `${Qi}-${t}` : void 0,
          role: e.focusable ? "button" : void 0
        },
        [
          _.value ? null : le(e.type === !1 ? s.value.default : e.type, {
            id: e.id,
            sourceNode: T.value,
            targetNode: p.value,
            source: f.value.source,
            target: f.value.target,
            type: f.value.type,
            updatable: e.updatable,
            selected: f.value.selected,
            animated: f.value.animated,
            label: f.value.label,
            labelStyle: f.value.labelStyle,
            labelShowBg: f.value.labelShowBg,
            labelBgStyle: f.value.labelBgStyle,
            labelBgPadding: f.value.labelBgPadding,
            labelBgBorderRadius: f.value.labelBgBorderRadius,
            data: f.value.data,
            events: { ...f.value.events, ...w.on },
            style: R.value,
            markerStart: `url(#${Ue(f.value.markerStart, t)})`,
            markerEnd: `url(#${Ue(f.value.markerEnd, t)})`,
            sourcePosition: b,
            targetPosition: z,
            sourceX: O,
            sourceY: V,
            targetX: N,
            targetY: Z,
            sourceHandleId: f.value.sourceHandle,
            targetHandleId: f.value.targetHandle,
            interactionWidth: f.value.interactionWidth
          }),
          [
            e.updatable === "source" || e.updatable === !0 ? [
              le(
                "g",
                {
                  onMousedown: j,
                  onMouseenter: H,
                  onMouseout: te
                },
                le(Uo, {
                  position: b,
                  centerX: O,
                  centerY: V,
                  radius: i.value,
                  type: "source",
                  "data-type": "source"
                })
              )
            ] : null,
            e.updatable === "target" || e.updatable === !0 ? [
              le(
                "g",
                {
                  onMousedown: ie,
                  onMouseenter: H,
                  onMouseout: te
                },
                le(Uo, {
                  position: z,
                  centerX: N,
                  centerY: Z,
                  radius: i.value,
                  type: "target",
                  "data-type": "target"
                })
              )
            ] : null
          ]
        ]
      );
    };
    function H() {
      d.value = !0;
    }
    function te() {
      d.value = !1;
    }
    function q(B, k) {
      w.emit.update({ event: B, edge: f.value, connection: k });
    }
    function m(B) {
      w.emit.updateEnd({ event: B, edge: f.value }), _.value = !1;
    }
    function L(B, k) {
      B.button === 0 && (_.value = !0, y.value = k ? f.value.target : f.value.source, S.value = (k ? f.value.targetHandle : f.value.sourceHandle) ?? "", A.value = k ? "target" : "source", x.value = A.value, w.emit.updateStart({ event: B, edge: f.value }), I(B));
    }
    function $(B) {
      const k = { event: B, edge: f.value };
      e.selectable && (a.value = !1, n([f.value])), w.emit.click(k);
    }
    function P(B) {
      w.emit.contextMenu({ event: B, edge: f.value });
    }
    function K(B) {
      w.emit.doubleClick({ event: B, edge: f.value });
    }
    function Y(B) {
      w.emit.mouseEnter({ event: B, edge: f.value });
    }
    function D(B) {
      w.emit.mouseMove({ event: B, edge: f.value });
    }
    function U(B) {
      w.emit.mouseLeave({ event: B, edge: f.value });
    }
    function j(B) {
      L(B, !0);
    }
    function ie(B) {
      L(B, !1);
    }
    function re(B) {
      var k;
      Ji.includes(B.key) && e.selectable && (B.key === "Escape" ? ((k = C.value) == null || k.blur(), u([c(e.id)])) : n([c(e.id)]));
    }
  }
}), Zs = Us, Ks = {
  height: "0",
  width: "0"
}, Ws = {
  name: "EdgeLabelRenderer",
  compatConfig: { MODE: 3 }
}, Bd = /* @__PURE__ */ ge({
  ...Ws,
  setup(e) {
    const { viewportRef: t } = ce(), n = W(() => {
      var o;
      return (o = t.value) == null ? void 0 : o.getElementsByClassName("vue-flow__edge-labels")[0];
    });
    return (o, i) => (oe(), ae("svg", null, [
      (oe(), ae("foreignObject", Ks, [
        (oe(), Te(Cr, {
          to: M(n),
          disabled: !M(n)
        }, [
          ye(o.$slots, "default")
        ], 8, ["to", "disabled"]))
      ]))
    ]));
  }
}), qs = { class: "vue-flow__connection" }, js = ["d", "marker-end", "marker-start"], Qs = {
  name: "ConnectionLine",
  compatConfig: { MODE: 3 }
}, Js = /* @__PURE__ */ ge({
  ...Qs,
  props: {
    sourceNode: null
  },
  setup(e) {
    var R;
    const t = ce(), n = E(t, "connectionMode"), o = E(t, "connectionStartHandle"), i = E(t, "connectionEndHandle"), r = E(t, "connectionPosition"), a = E(t, "connectionLineType"), l = E(t, "connectionLineStyle"), s = E(t, "connectionLineOptions"), u = E(t, "connectionStatus"), c = E(t, "viewport"), g = E(t, "findNode"), v = {
      [J.Left]: J.Right,
      [J.Right]: J.Left,
      [J.Top]: J.Bottom,
      [J.Bottom]: J.Top
    }, w = (R = He(an)) == null ? void 0 : R["connection-line"], f = W(() => o.value.handleId), d = W(() => o.value.type), _ = W(() => {
      var I;
      return ((I = i.value) == null ? void 0 : I.handleId) && g.value(i.value.nodeId) || null;
    }), y = W(
      () => {
        var I, H;
        return (n.value === Qe.Strict ? (I = e.sourceNode.handleBounds[d.value]) == null ? void 0 : I.find((te) => te.id === f.value) : [...e.sourceNode.handleBounds.source || [], ...e.sourceNode.handleBounds.target || []].find((te) => te.id === f.value)) || ((H = e.sourceNode.handleBounds[d.value ?? "source"]) == null ? void 0 : H[0]);
      }
    ), S = W(() => {
      var I, H, te;
      return _.value && ((I = i.value) == null ? void 0 : I.handleId) && ((n.value === Qe.Strict ? (H = _.value.handleBounds[d.value === "source" ? "target" : "source"]) == null ? void 0 : H.find(
        (q) => {
          var m;
          return q.id === ((m = i.value) == null ? void 0 : m.handleId);
        }
      ) : [..._.value.handleBounds.source || [], ..._.value.handleBounds.target || []].find(
        (q) => {
          var m;
          return q.id === ((m = i.value) == null ? void 0 : m.handleId);
        }
      )) || ((te = _.value.handleBounds[d.value ?? "target"]) == null ? void 0 : te[0])) || null;
    }), A = W(() => {
      var I;
      return (I = y.value) == null ? void 0 : I.position;
    }), x = W(() => y.value ? Ut(
      A.value || J.Top,
      { ...e.sourceNode.dimensions, ...e.sourceNode.computedPosition },
      y.value
    ) : {
      x: e.sourceNode.dimensions.width / 2,
      y: e.sourceNode.dimensions.height / 2
    }), C = W(() => A.value ? v[A.value] : void 0), T = W(() => (r.value.x - c.value.x) / c.value.zoom), p = W(() => (r.value.y - c.value.y) / c.value.zoom), G = W(() => {
      let I;
      const H = {
        sourceX: x.value.x,
        sourceY: x.value.y,
        sourcePosition: A.value,
        targetX: T.value,
        targetY: p.value,
        targetPosition: C.value
      };
      switch (a.value ?? s.value.type) {
        case Xe.Bezier:
          [I] = Zn(H);
          break;
        case Xe.Step:
          [I] = Kn({
            ...H,
            borderRadius: 0
          });
          break;
        case Xe.SmoothStep:
          [I] = Kn(H);
          break;
        case Xe.SimpleBezier:
          [I] = nr(H);
          break;
        case Xe.Straight:
          [I] = ir(H);
          break;
        default:
          [I] = Zn(H);
          break;
      }
      return I;
    });
    return (I, H) => {
      var te;
      return oe(), ae("g", qs, [
        M(w) ? (oe(), Te(vi(M(w)), Mr(gi({ key: 0 }, {
          sourceX: M(x).x,
          sourceY: M(x).y,
          sourcePosition: (te = M(y)) == null ? void 0 : te.position,
          targetX: M(T),
          targetY: M(p),
          targetPosition: M(C),
          sourceNode: e.sourceNode,
          sourceHandle: M(y),
          targetNode: M(_),
          targetHandle: M(S),
          markerEnd: `url(#${M(Ue)(M(s).markerEnd)})`,
          markerStart: `url(#${M(Ue)(M(s).markerStart)})`,
          connectionStatus: M(u)
        })), null, 16)) : (oe(), ae("path", {
          key: 1,
          d: M(G),
          class: qe(["vue-flow__connection-path", [M(s).class, M(u)]]),
          style: Le(M(l) || M(s).style || {}),
          "marker-end": `url(#${M(Ue)(M(s).markerEnd)})`,
          "marker-start": `url(#${M(Ue)(M(s).markerStart)})`
        }, null, 14, js))
      ]);
    };
  }
}), eu = ["tabIndex"], tu = {
  name: "NodesSelection",
  compatConfig: { MODE: 3 }
}, nu = /* @__PURE__ */ ge({
  ...tu,
  setup(e) {
    const t = ce(), n = E(t, "emits"), o = E(t, "viewport"), i = E(t, "getSelectedNodes"), r = E(t, "noPanClassName"), a = E(t, "disableKeyboardA11y"), l = E(t, "userSelectionActive"), s = zi(), u = ne(), c = qi({
      el: u,
      onStart(d, _, y) {
        n.value.selectionDragStart({ event: d, node: _, nodes: y });
      },
      onDrag(d, _, y) {
        n.value.selectionDrag({ event: d, node: _, nodes: y });
      },
      onStop(d, _, y) {
        n.value.selectionDragStop({ event: d, node: _, nodes: y });
      }
    });
    Ve(() => {
      var d;
      a.value || (d = u.value) == null || d.focus({ preventScroll: !0 });
    });
    const g = W(() => uo(i.value)), v = W(() => ({
      width: `${g.value.width}px`,
      height: `${g.value.height}px`,
      top: `${g.value.y}px`,
      left: `${g.value.x}px`
    }));
    function w(d) {
      n.value.selectionContextMenu({ event: d, nodes: i.value });
    }
    function f(d) {
      a.value || rt[d.key] && s(
        {
          x: rt[d.key].x,
          y: rt[d.key].y
        },
        d.shiftKey
      );
    }
    return (d, _) => !M(l) && M(g).width && M(g).height ? (oe(), ae("div", {
      key: 0,
      class: qe(["vue-flow__nodesselection vue-flow__container", M(r)]),
      style: Le({ transform: `translate(${M(o).x}px,${M(o).y}px) scale(${M(o).zoom})` })
    }, [
      st("div", {
        ref_key: "el",
        ref: u,
        class: qe([{ dragging: M(c) }, "vue-flow__nodesselection-rect"]),
        style: Le(M(v)),
        tabIndex: M(a) ? void 0 : -1,
        onContextmenu: w,
        onKeydown: f
      }, null, 46, eu)
    ], 6)) : be("", !0);
  }
}), ou = {
  name: "UserSelection",
  compatConfig: { MODE: 3 }
}, iu = /* @__PURE__ */ ge({
  ...ou,
  setup(e) {
    const { userSelectionRect: t } = ce();
    return (n, o) => {
      var i, r, a, l;
      return oe(), ae("div", {
        class: "vue-flow__selection vue-flow__container",
        style: Le({
          width: `${(i = M(t)) == null ? void 0 : i.width}px`,
          height: `${(r = M(t)) == null ? void 0 : r.height}px`,
          transform: `translate(${(a = M(t)) == null ? void 0 : a.x}px, ${(l = M(t)) == null ? void 0 : l.y}px)`
        })
      }, null, 4);
    };
  }
}), ru = {
  input: $a,
  default: Ma,
  output: ka
}, au = {
  default: zs,
  straight: Ls,
  step: Hs,
  smoothstep: or,
  simplebezier: As
};
function lu() {
  return {
    vueFlowRef: null,
    viewportRef: null,
    nodes: [],
    edges: [],
    nodeTypes: {},
    edgeTypes: {},
    initialized: !1,
    dimensions: {
      width: 0,
      height: 0
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    d3Zoom: null,
    d3Selection: null,
    d3ZoomHandler: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    nodeExtent: [
      [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
      [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
    ],
    selectionMode: co.Full,
    paneDragging: !1,
    preventScrolling: !0,
    zoomOnScroll: !0,
    zoomOnPinch: !0,
    zoomOnDoubleClick: !0,
    panOnScroll: !1,
    panOnScrollSpeed: 0.5,
    panOnScrollMode: Xt.Free,
    panOnDrag: !0,
    edgeUpdaterRadius: 10,
    onlyRenderVisibleElements: !1,
    defaultViewport: { x: 0, y: 0, zoom: 1 },
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    defaultMarkerColor: "#b1b1b7",
    connectionLineStyle: {},
    connectionLineType: null,
    connectionLineOptions: {
      type: Xe.Bezier,
      style: {}
    },
    connectionMode: Qe.Loose,
    connectionStartHandle: null,
    connectionEndHandle: null,
    connectionClickStartHandle: null,
    connectionPosition: { x: NaN, y: NaN },
    connectionRadius: 20,
    connectOnClick: !0,
    connectionStatus: null,
    isValidConnection: null,
    snapGrid: [15, 15],
    snapToGrid: !1,
    edgesUpdatable: !1,
    edgesFocusable: !0,
    nodesFocusable: !0,
    nodesConnectable: !0,
    nodesDraggable: !0,
    elementsSelectable: !0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    selectionKeyCode: "Shift",
    multiSelectionKeyCode: "Meta",
    zoomActivationKeyCode: "Meta",
    deleteKeyCode: "Backspace",
    panActivationKeyCode: "Space",
    hooks: sa(),
    applyDefault: !0,
    autoConnect: !1,
    fitViewOnInit: !1,
    noDragClassName: "nodrag",
    noWheelClassName: "nowheel",
    noPanClassName: "nopan",
    defaultEdgeOptions: void 0,
    elevateEdgesOnSelect: !1,
    elevateNodesOnSelect: !0,
    autoPanOnNodeDrag: !0,
    autoPanOnConnect: !0,
    disableKeyboardA11y: !1,
    ariaLiveMessage: "",
    __experimentalFeatures: {
      nestedFlow: !1
    },
    vueFlowVersion: "1.18.2"
  };
}
function rr(e) {
  const t = lu();
  return e && Object.keys(e).forEach((n) => {
    const o = e[n];
    de(o) && (t[n] = o);
  }), t;
}
function su(e) {
  const t = W(() => e.nodes.map((d) => d.id)), n = W(() => e.edges.map((d) => d.id)), o = W(() => (d) => e.nodes && !t.value.length ? e.nodes.find((_) => _.id === d) : e.nodes[t.value.indexOf(d)]), i = W(() => (d) => e.edges && !n.value.length ? e.edges.find((_) => _.id === d) : e.edges[n.value.indexOf(d)]), r = W(() => {
    var y;
    const d = {
      ...au,
      ...e.edgeTypes
    }, _ = Object.keys(d);
    return (y = e.edges) == null || y.forEach((S) => S.type && !_.includes(S.type) && (d[S.type] = S.type)), d;
  }), a = W(() => {
    var y;
    const d = {
      ...ru,
      ...e.nodeTypes
    }, _ = Object.keys(d);
    return (y = e.nodes) == null || y.forEach((S) => S.type && !_.includes(S.type) && (d[S.type] = S.type)), d;
  }), l = W(() => {
    const d = e.nodes.filter((_) => !_.hidden);
    return e.onlyRenderVisibleElements ? d && Ci(
      d,
      {
        x: 0,
        y: 0,
        width: e.dimensions.width,
        height: e.dimensions.height
      },
      e.viewport,
      !0
    ) : d ?? [];
  }), s = (d, _, y) => {
    if (_ = _ ?? o.value(d.source), y = y ?? o.value(d.target), !_ || !y) {
      e.hooks.error.trigger(new ve(he.EDGE_ORPHANED, d.id));
      return;
    }
    return !d.hidden && !y.hidden && !_.hidden;
  }, u = W(() => e.onlyRenderVisibleElements ? e.edges.filter((d) => {
    const _ = o.value(d.source), y = o.value(d.target);
    return s(d, _, y) && xa({
      sourcePos: _.computedPosition || { x: 0, y: 0 },
      targetPos: y.computedPosition || { x: 0, y: 0 },
      sourceWidth: _.dimensions.width,
      sourceHeight: _.dimensions.height,
      targetWidth: y.dimensions.width,
      targetHeight: y.dimensions.height,
      width: e.dimensions.width,
      height: e.dimensions.height,
      viewport: e.viewport
    });
  }) : e.edges.filter((d) => s(d))), c = W(() => [...l.value, ...u.value]), g = W(() => e.nodes.filter((d) => d.selected)), v = W(() => e.edges.filter((d) => d.selected)), w = W(() => [
    ...g.value ?? [],
    ...v.value ?? []
  ]), f = W(
    () => l.value.filter((d) => d.initialized && d.handleBounds !== void 0)
  );
  return {
    getNode: o,
    getEdge: i,
    getElements: c,
    getEdgeTypes: r,
    getNodeTypes: a,
    getEdges: u,
    getNodes: l,
    getSelectedElements: w,
    getSelectedNodes: g,
    getSelectedEdges: v,
    getNodesInitialized: f
  };
}
function mo(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function ar(e, t) {
  var n = Object.create(e.prototype);
  for (var o in t)
    n[o] = t[o];
  return n;
}
function $t() {
}
var Et = 0.7, Wt = 1 / Et, at = "\\s*([+-]?\\d+)\\s*", St = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Ce = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", uu = /^#([0-9a-f]{3,8})$/, cu = new RegExp(`^rgb\\(${at},${at},${at}\\)$`), du = new RegExp(`^rgb\\(${Ce},${Ce},${Ce}\\)$`), fu = new RegExp(`^rgba\\(${at},${at},${at},${St}\\)$`), hu = new RegExp(`^rgba\\(${Ce},${Ce},${Ce},${St}\\)$`), gu = new RegExp(`^hsl\\(${St},${Ce},${Ce}\\)$`), vu = new RegExp(`^hsla\\(${St},${Ce},${Ce},${St}\\)$`), Zo = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
mo($t, Nt, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: Ko,
  // Deprecated! Use color.formatHex.
  formatHex: Ko,
  formatHex8: pu,
  formatHsl: mu,
  formatRgb: Wo,
  toString: Wo
});
function Ko() {
  return this.rgb().formatHex();
}
function pu() {
  return this.rgb().formatHex8();
}
function mu() {
  return lr(this).formatHsl();
}
function Wo() {
  return this.rgb().formatRgb();
}
function Nt(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = uu.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? qo(t) : n === 3 ? new me(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Pt(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Pt(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = cu.exec(e)) ? new me(t[1], t[2], t[3], 1) : (t = du.exec(e)) ? new me(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = fu.exec(e)) ? Pt(t[1], t[2], t[3], t[4]) : (t = hu.exec(e)) ? Pt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = gu.exec(e)) ? Jo(t[1], t[2] / 100, t[3] / 100, 1) : (t = vu.exec(e)) ? Jo(t[1], t[2] / 100, t[3] / 100, t[4]) : Zo.hasOwnProperty(e) ? qo(Zo[e]) : e === "transparent" ? new me(NaN, NaN, NaN, 0) : null;
}
function qo(e) {
  return new me(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Pt(e, t, n, o) {
  return o <= 0 && (e = t = n = NaN), new me(e, t, n, o);
}
function yu(e) {
  return e instanceof $t || (e = Nt(e)), e ? (e = e.rgb(), new me(e.r, e.g, e.b, e.opacity)) : new me();
}
function Wn(e, t, n, o) {
  return arguments.length === 1 ? yu(e) : new me(e, t, n, o ?? 1);
}
function me(e, t, n, o) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +o;
}
mo(me, Wn, ar($t, {
  brighter(e) {
    return e = e == null ? Wt : Math.pow(Wt, e), new me(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Et : Math.pow(Et, e), new me(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new me(We(this.r), We(this.g), We(this.b), qt(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: jo,
  // Deprecated! Use color.formatHex.
  formatHex: jo,
  formatHex8: xu,
  formatRgb: Qo,
  toString: Qo
}));
function jo() {
  return `#${Ze(this.r)}${Ze(this.g)}${Ze(this.b)}`;
}
function xu() {
  return `#${Ze(this.r)}${Ze(this.g)}${Ze(this.b)}${Ze((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function Qo() {
  const e = qt(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${We(this.r)}, ${We(this.g)}, ${We(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function qt(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function We(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ze(e) {
  return e = We(e), (e < 16 ? "0" : "") + e.toString(16);
}
function Jo(e, t, n, o) {
  return o <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new we(e, t, n, o);
}
function lr(e) {
  if (e instanceof we)
    return new we(e.h, e.s, e.l, e.opacity);
  if (e instanceof $t || (e = Nt(e)), !e)
    return new we();
  if (e instanceof we)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, o = e.b / 255, i = Math.min(t, n, o), r = Math.max(t, n, o), a = NaN, l = r - i, s = (r + i) / 2;
  return l ? (t === r ? a = (n - o) / l + (n < o) * 6 : n === r ? a = (o - t) / l + 2 : a = (t - n) / l + 4, l /= s < 0.5 ? r + i : 2 - r - i, a *= 60) : l = s > 0 && s < 1 ? 0 : a, new we(a, l, s, e.opacity);
}
function _u(e, t, n, o) {
  return arguments.length === 1 ? lr(e) : new we(e, t, n, o ?? 1);
}
function we(e, t, n, o) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +o;
}
mo(we, _u, ar($t, {
  brighter(e) {
    return e = e == null ? Wt : Math.pow(Wt, e), new we(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Et : Math.pow(Et, e), new we(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - o;
    return new me(
      Cn(e >= 240 ? e - 240 : e + 120, i, o),
      Cn(e, i, o),
      Cn(e < 120 ? e + 240 : e - 120, i, o),
      this.opacity
    );
  },
  clamp() {
    return new we(ei(this.h), Dt(this.s), Dt(this.l), qt(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = qt(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${ei(this.h)}, ${Dt(this.s) * 100}%, ${Dt(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function ei(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Dt(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function Cn(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const sr = (e) => () => e;
function wu(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function bu(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(o) {
    return Math.pow(e + o * t, n);
  };
}
function Eu(e) {
  return (e = +e) == 1 ? ur : function(t, n) {
    return n - t ? bu(t, n, e) : sr(isNaN(t) ? n : t);
  };
}
function ur(e, t) {
  var n = t - e;
  return n ? wu(e, n) : sr(isNaN(e) ? t : e);
}
const ti = function e(t) {
  var n = Eu(t);
  function o(i, r) {
    var a = n((i = Wn(i)).r, (r = Wn(r)).r), l = n(i.g, r.g), s = n(i.b, r.b), u = ur(i.opacity, r.opacity);
    return function(c) {
      return i.r = a(c), i.g = l(c), i.b = s(c), i.opacity = u(c), i + "";
    };
  }
  return o.gamma = e, o;
}(1);
function Ae(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var qn = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, Mn = new RegExp(qn.source, "g");
function Su(e) {
  return function() {
    return e;
  };
}
function Nu(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Cu(e, t) {
  var n = qn.lastIndex = Mn.lastIndex = 0, o, i, r, a = -1, l = [], s = [];
  for (e = e + "", t = t + ""; (o = qn.exec(e)) && (i = Mn.exec(t)); )
    (r = i.index) > n && (r = t.slice(n, r), l[a] ? l[a] += r : l[++a] = r), (o = o[0]) === (i = i[0]) ? l[a] ? l[a] += i : l[++a] = i : (l[++a] = null, s.push({ i: a, x: Ae(o, i) })), n = Mn.lastIndex;
  return n < t.length && (r = t.slice(n), l[a] ? l[a] += r : l[++a] = r), l.length < 2 ? s[0] ? Nu(s[0].x) : Su(t) : (t = s.length, function(u) {
    for (var c = 0, g; c < t; ++c)
      l[(g = s[c]).i] = g.x(u);
    return l.join("");
  });
}
var ni = 180 / Math.PI, jn = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function cr(e, t, n, o, i, r) {
  var a, l, s;
  return (a = Math.sqrt(e * e + t * t)) && (e /= a, t /= a), (s = e * n + t * o) && (n -= e * s, o -= t * s), (l = Math.sqrt(n * n + o * o)) && (n /= l, o /= l, s /= l), e * o < t * n && (e = -e, t = -t, s = -s, a = -a), {
    translateX: i,
    translateY: r,
    rotate: Math.atan2(t, e) * ni,
    skewX: Math.atan(s) * ni,
    scaleX: a,
    scaleY: l
  };
}
var zt;
function Mu(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? jn : cr(t.a, t.b, t.c, t.d, t.e, t.f);
}
function $u(e) {
  return e == null || (zt || (zt = document.createElementNS("http://www.w3.org/2000/svg", "g")), zt.setAttribute("transform", e), !(e = zt.transform.baseVal.consolidate())) ? jn : (e = e.matrix, cr(e.a, e.b, e.c, e.d, e.e, e.f));
}
function dr(e, t, n, o) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function r(u, c, g, v, w, f) {
    if (u !== g || c !== v) {
      var d = w.push("translate(", null, t, null, n);
      f.push({ i: d - 4, x: Ae(u, g) }, { i: d - 2, x: Ae(c, v) });
    } else
      (g || v) && w.push("translate(" + g + t + v + n);
  }
  function a(u, c, g, v) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), v.push({ i: g.push(i(g) + "rotate(", null, o) - 2, x: Ae(u, c) })) : c && g.push(i(g) + "rotate(" + c + o);
  }
  function l(u, c, g, v) {
    u !== c ? v.push({ i: g.push(i(g) + "skewX(", null, o) - 2, x: Ae(u, c) }) : c && g.push(i(g) + "skewX(" + c + o);
  }
  function s(u, c, g, v, w, f) {
    if (u !== g || c !== v) {
      var d = w.push(i(w) + "scale(", null, ",", null, ")");
      f.push({ i: d - 4, x: Ae(u, g) }, { i: d - 2, x: Ae(c, v) });
    } else
      (g !== 1 || v !== 1) && w.push(i(w) + "scale(" + g + "," + v + ")");
  }
  return function(u, c) {
    var g = [], v = [];
    return u = e(u), c = e(c), r(u.translateX, u.translateY, c.translateX, c.translateY, g, v), a(u.rotate, c.rotate, g, v), l(u.skewX, c.skewX, g, v), s(u.scaleX, u.scaleY, c.scaleX, c.scaleY, g, v), u = c = null, function(w) {
      for (var f = -1, d = v.length, _; ++f < d; )
        g[(_ = v[f]).i] = _.x(w);
      return g.join("");
    };
  };
}
var ku = dr(Mu, "px, ", "px)", "deg)"), Iu = dr($u, ", ", ")", ")"), Ou = 1e-12;
function oi(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function Tu(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Pu(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Du = function e(t, n, o) {
  function i(r, a) {
    var l = r[0], s = r[1], u = r[2], c = a[0], g = a[1], v = a[2], w = c - l, f = g - s, d = w * w + f * f, _, y;
    if (d < Ou)
      y = Math.log(v / u) / t, _ = function(p) {
        return [
          l + p * w,
          s + p * f,
          u * Math.exp(t * p * y)
        ];
      };
    else {
      var S = Math.sqrt(d), A = (v * v - u * u + o * d) / (2 * u * n * S), x = (v * v - u * u - o * d) / (2 * v * n * S), C = Math.log(Math.sqrt(A * A + 1) - A), T = Math.log(Math.sqrt(x * x + 1) - x);
      y = (T - C) / t, _ = function(p) {
        var G = p * y, R = oi(C), I = u / (n * S) * (R * Pu(t * G + C) - Tu(C));
        return [
          l + I * w,
          s + I * f,
          u * R / oi(t * G + C)
        ];
      };
    }
    return _.duration = y * 1e3 * t / Math.SQRT2, _;
  }
  return i.rho = function(r) {
    var a = Math.max(1e-3, +r), l = a * a, s = l * l;
    return e(a, l, s);
  }, i;
}(Math.SQRT2, 2, 4);
var ft = 0, mt = 0, vt = 0, fr = 1e3, jt, yt, Qt = 0, Je = 0, xn = 0, Ct = typeof performance == "object" && performance.now ? performance : Date, hr = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function yo() {
  return Je || (hr(zu), Je = Ct.now() + xn);
}
function zu() {
  Je = 0;
}
function Jt() {
  this._call = this._time = this._next = null;
}
Jt.prototype = gr.prototype = {
  constructor: Jt,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? yo() : +n) + (t == null ? 0 : +t), !this._next && yt !== this && (yt ? yt._next = this : jt = this, yt = this), this._call = e, this._time = n, Qn();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Qn());
  }
};
function gr(e, t, n) {
  var o = new Jt();
  return o.restart(e, t, n), o;
}
function Au() {
  yo(), ++ft;
  for (var e = jt, t; e; )
    (t = Je - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --ft;
}
function ii() {
  Je = (Qt = Ct.now()) + xn, ft = mt = 0;
  try {
    Au();
  } finally {
    ft = 0, Ru(), Je = 0;
  }
}
function Bu() {
  var e = Ct.now(), t = e - Qt;
  t > fr && (xn -= t, Qt = e);
}
function Ru() {
  for (var e, t = jt, n, o = 1 / 0; t; )
    t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : jt = n);
  yt = e, Qn(o);
}
function Qn(e) {
  if (!ft) {
    mt && (mt = clearTimeout(mt));
    var t = e - Je;
    t > 24 ? (e < 1 / 0 && (mt = setTimeout(ii, e - Ct.now() - xn)), vt && (vt = clearInterval(vt))) : (vt || (Qt = Ct.now(), vt = setInterval(Bu, fr)), ft = 1, hr(ii));
  }
}
function ri(e, t, n) {
  var o = new Jt();
  return t = t == null ? 0 : +t, o.restart((i) => {
    o.stop(), e(i + t);
  }, t, n), o;
}
var Vu = cn("start", "end", "cancel", "interrupt"), Hu = [], vr = 0, ai = 1, Jn = 2, Vt = 3, li = 4, eo = 5, Ht = 6;
function _n(e, t, n, o, i, r) {
  var a = e.__transition;
  if (!a)
    e.__transition = {};
  else if (n in a)
    return;
  Lu(e, n, {
    name: t,
    index: o,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Vu,
    tween: Hu,
    time: r.time,
    delay: r.delay,
    duration: r.duration,
    ease: r.ease,
    timer: null,
    state: vr
  });
}
function xo(e, t) {
  var n = Ee(e, t);
  if (n.state > vr)
    throw new Error("too late; already scheduled");
  return n;
}
function Me(e, t) {
  var n = Ee(e, t);
  if (n.state > Vt)
    throw new Error("too late; already running");
  return n;
}
function Ee(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Lu(e, t, n) {
  var o = e.__transition, i;
  o[t] = n, n.timer = gr(r, 0, n.time);
  function r(u) {
    n.state = ai, n.timer.restart(a, n.delay, n.time), n.delay <= u && a(u - n.delay);
  }
  function a(u) {
    var c, g, v, w;
    if (n.state !== ai)
      return s();
    for (c in o)
      if (w = o[c], w.name === n.name) {
        if (w.state === Vt)
          return ri(a);
        w.state === li ? (w.state = Ht, w.timer.stop(), w.on.call("interrupt", e, e.__data__, w.index, w.group), delete o[c]) : +c < t && (w.state = Ht, w.timer.stop(), w.on.call("cancel", e, e.__data__, w.index, w.group), delete o[c]);
      }
    if (ri(function() {
      n.state === Vt && (n.state = li, n.timer.restart(l, n.delay, n.time), l(u));
    }), n.state = Jn, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Jn) {
      for (n.state = Vt, i = new Array(v = n.tween.length), c = 0, g = -1; c < v; ++c)
        (w = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (i[++g] = w);
      i.length = g + 1;
    }
  }
  function l(u) {
    for (var c = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(s), n.state = eo, 1), g = -1, v = i.length; ++g < v; )
      i[g].call(e, c);
    n.state === eo && (n.on.call("end", e, e.__data__, n.index, n.group), s());
  }
  function s() {
    n.state = Ht, n.timer.stop(), delete o[t];
    for (var u in o)
      return;
    delete e.__transition;
  }
}
function Lt(e, t) {
  var n = e.__transition, o, i, r = !0, a;
  if (n) {
    t = t == null ? null : t + "";
    for (a in n) {
      if ((o = n[a]).name !== t) {
        r = !1;
        continue;
      }
      i = o.state > Jn && o.state < eo, o.state = Ht, o.timer.stop(), o.on.call(i ? "interrupt" : "cancel", e, e.__data__, o.index, o.group), delete n[a];
    }
    r && delete e.__transition;
  }
}
function Fu(e) {
  return this.each(function() {
    Lt(this, e);
  });
}
function Gu(e, t) {
  var n, o;
  return function() {
    var i = Me(this, e), r = i.tween;
    if (r !== n) {
      o = n = r;
      for (var a = 0, l = o.length; a < l; ++a)
        if (o[a].name === t) {
          o = o.slice(), o.splice(a, 1);
          break;
        }
    }
    i.tween = o;
  };
}
function Yu(e, t, n) {
  var o, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var r = Me(this, e), a = r.tween;
    if (a !== o) {
      i = (o = a).slice();
      for (var l = { name: t, value: n }, s = 0, u = i.length; s < u; ++s)
        if (i[s].name === t) {
          i[s] = l;
          break;
        }
      s === u && i.push(l);
    }
    r.tween = i;
  };
}
function Xu(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var o = Ee(this.node(), n).tween, i = 0, r = o.length, a; i < r; ++i)
      if ((a = o[i]).name === e)
        return a.value;
    return null;
  }
  return this.each((t == null ? Gu : Yu)(n, e, t));
}
function _o(e, t, n) {
  var o = e._id;
  return e.each(function() {
    var i = Me(this, o);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Ee(i, o).value[t];
  };
}
function pr(e, t) {
  var n;
  return (typeof t == "number" ? Ae : t instanceof Nt ? ti : (n = Nt(t)) ? (t = n, ti) : Cu)(e, t);
}
function Uu(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Zu(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Ku(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = this.getAttribute(e);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Wu(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = this.getAttributeNS(e.space, e.local);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function qu(e, t, n) {
  var o, i, r;
  return function() {
    var a, l = n(this), s;
    return l == null ? void this.removeAttribute(e) : (a = this.getAttribute(e), s = l + "", a === s ? null : a === o && s === i ? r : (i = s, r = t(o = a, l)));
  };
}
function ju(e, t, n) {
  var o, i, r;
  return function() {
    var a, l = n(this), s;
    return l == null ? void this.removeAttributeNS(e.space, e.local) : (a = this.getAttributeNS(e.space, e.local), s = l + "", a === s ? null : a === o && s === i ? r : (i = s, r = t(o = a, l)));
  };
}
function Qu(e, t) {
  var n = dn(e), o = n === "transform" ? Iu : pr;
  return this.attrTween(e, typeof t == "function" ? (n.local ? ju : qu)(n, o, _o(this, "attr." + e, t)) : t == null ? (n.local ? Zu : Uu)(n) : (n.local ? Wu : Ku)(n, o, t));
}
function Ju(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function ec(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function tc(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && ec(e, r)), n;
  }
  return i._value = t, i;
}
function nc(e, t) {
  var n, o;
  function i() {
    var r = t.apply(this, arguments);
    return r !== o && (n = (o = r) && Ju(e, r)), n;
  }
  return i._value = t, i;
}
function oc(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var o = dn(e);
  return this.tween(n, (o.local ? tc : nc)(o, t));
}
function ic(e, t) {
  return function() {
    xo(this, e).delay = +t.apply(this, arguments);
  };
}
function rc(e, t) {
  return t = +t, function() {
    xo(this, e).delay = t;
  };
}
function ac(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? ic : rc)(t, e)) : Ee(this.node(), t).delay;
}
function lc(e, t) {
  return function() {
    Me(this, e).duration = +t.apply(this, arguments);
  };
}
function sc(e, t) {
  return t = +t, function() {
    Me(this, e).duration = t;
  };
}
function uc(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? lc : sc)(t, e)) : Ee(this.node(), t).duration;
}
function cc(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    Me(this, e).ease = t;
  };
}
function dc(e) {
  var t = this._id;
  return arguments.length ? this.each(cc(t, e)) : Ee(this.node(), t).ease;
}
function fc(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    Me(this, e).ease = n;
  };
}
function hc(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(fc(this._id, e));
}
function gc(e) {
  typeof e != "function" && (e = Ri(e));
  for (var t = this._groups, n = t.length, o = new Array(n), i = 0; i < n; ++i)
    for (var r = t[i], a = r.length, l = o[i] = [], s, u = 0; u < a; ++u)
      (s = r[u]) && e.call(s, s.__data__, u, r) && l.push(s);
  return new ze(o, this._parents, this._name, this._id);
}
function vc(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, o = t.length, i = n.length, r = Math.min(o, i), a = new Array(o), l = 0; l < r; ++l)
    for (var s = t[l], u = n[l], c = s.length, g = a[l] = new Array(c), v, w = 0; w < c; ++w)
      (v = s[w] || u[w]) && (g[w] = v);
  for (; l < o; ++l)
    a[l] = t[l];
  return new ze(a, this._parents, this._name, this._id);
}
function pc(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function mc(e, t, n) {
  var o, i, r = pc(t) ? xo : Me;
  return function() {
    var a = r(this, e), l = a.on;
    l !== o && (i = (o = l).copy()).on(t, n), a.on = i;
  };
}
function yc(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ee(this.node(), n).on.on(e) : this.each(mc(n, e, t));
}
function xc(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function _c() {
  return this.on("end.remove", xc(this._id));
}
function wc(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = go(e));
  for (var o = this._groups, i = o.length, r = new Array(i), a = 0; a < i; ++a)
    for (var l = o[a], s = l.length, u = r[a] = new Array(s), c, g, v = 0; v < s; ++v)
      (c = l[v]) && (g = e.call(c, c.__data__, v, l)) && ("__data__" in c && (g.__data__ = c.__data__), u[v] = g, _n(u[v], t, n, v, u, Ee(c, n)));
  return new ze(r, this._parents, t, n);
}
function bc(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Bi(e));
  for (var o = this._groups, i = o.length, r = [], a = [], l = 0; l < i; ++l)
    for (var s = o[l], u = s.length, c, g = 0; g < u; ++g)
      if (c = s[g]) {
        for (var v = e.call(c, c.__data__, g, s), w, f = Ee(c, n), d = 0, _ = v.length; d < _; ++d)
          (w = v[d]) && _n(w, t, n, d, v, f);
        r.push(v), a.push(c);
      }
  return new ze(r, a, t, n);
}
var Ec = Mt.prototype.constructor;
function Sc() {
  return new Ec(this._groups, this._parents);
}
function Nc(e, t) {
  var n, o, i;
  return function() {
    var r = dt(this, e), a = (this.style.removeProperty(e), dt(this, e));
    return r === a ? null : r === n && a === o ? i : i = t(n = r, o = a);
  };
}
function mr(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Cc(e, t, n) {
  var o, i = n + "", r;
  return function() {
    var a = dt(this, e);
    return a === i ? null : a === o ? r : r = t(o = a, n);
  };
}
function Mc(e, t, n) {
  var o, i, r;
  return function() {
    var a = dt(this, e), l = n(this), s = l + "";
    return l == null && (s = l = (this.style.removeProperty(e), dt(this, e))), a === s ? null : a === o && s === i ? r : (i = s, r = t(o = a, l));
  };
}
function $c(e, t) {
  var n, o, i, r = "style." + t, a = "end." + r, l;
  return function() {
    var s = Me(this, e), u = s.on, c = s.value[r] == null ? l || (l = mr(t)) : void 0;
    (u !== n || i !== c) && (o = (n = u).copy()).on(a, i = c), s.on = o;
  };
}
function kc(e, t, n) {
  var o = (e += "") == "transform" ? ku : pr;
  return t == null ? this.styleTween(e, Nc(e, o)).on("end.style." + e, mr(e)) : typeof t == "function" ? this.styleTween(e, Mc(e, o, _o(this, "style." + e, t))).each($c(this._id, e)) : this.styleTween(e, Cc(e, o, t), n).on("end.style." + e, null);
}
function Ic(e, t, n) {
  return function(o) {
    this.style.setProperty(e, t.call(this, o), n);
  };
}
function Oc(e, t, n) {
  var o, i;
  function r() {
    var a = t.apply(this, arguments);
    return a !== i && (o = (i = a) && Ic(e, a, n)), o;
  }
  return r._value = t, r;
}
function Tc(e, t, n) {
  var o = "style." + (e += "");
  if (arguments.length < 2)
    return (o = this.tween(o)) && o._value;
  if (t == null)
    return this.tween(o, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(o, Oc(e, t, n ?? ""));
}
function Pc(e) {
  return function() {
    this.textContent = e;
  };
}
function Dc(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function zc(e) {
  return this.tween("text", typeof e == "function" ? Dc(_o(this, "text", e)) : Pc(e == null ? "" : e + ""));
}
function Ac(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Bc(e) {
  var t, n;
  function o() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && Ac(i)), t;
  }
  return o._value = e, o;
}
function Rc(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, Bc(e));
}
function Vc() {
  for (var e = this._name, t = this._id, n = yr(), o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var a = o[r], l = a.length, s, u = 0; u < l; ++u)
      if (s = a[u]) {
        var c = Ee(s, t);
        _n(s, e, n, u, a, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new ze(o, this._parents, e, n);
}
function Hc() {
  var e, t, n = this, o = n._id, i = n.size();
  return new Promise(function(r, a) {
    var l = { value: a }, s = { value: function() {
      --i === 0 && r();
    } };
    n.each(function() {
      var u = Me(this, o), c = u.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(l), t._.interrupt.push(l), t._.end.push(s)), u.on = t;
    }), i === 0 && r();
  });
}
var Lc = 0;
function ze(e, t, n, o) {
  this._groups = e, this._parents = t, this._name = n, this._id = o;
}
function yr() {
  return ++Lc;
}
var $e = Mt.prototype;
ze.prototype = {
  constructor: ze,
  select: wc,
  selectAll: bc,
  selectChild: $e.selectChild,
  selectChildren: $e.selectChildren,
  filter: gc,
  merge: vc,
  selection: Sc,
  transition: Vc,
  call: $e.call,
  nodes: $e.nodes,
  node: $e.node,
  size: $e.size,
  empty: $e.empty,
  each: $e.each,
  on: yc,
  attr: Qu,
  attrTween: oc,
  style: kc,
  styleTween: Tc,
  text: zc,
  textTween: Rc,
  remove: _c,
  tween: Xu,
  delay: ac,
  duration: uc,
  ease: dc,
  easeVarying: hc,
  end: Hc,
  [Symbol.iterator]: $e[Symbol.iterator]
};
function Fc(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Gc = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Fc
};
function Yc(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Xc(e) {
  var t, n;
  e instanceof ze ? (t = e._id, e = e._name) : (t = yr(), (n = Gc).time = yo(), e = e == null ? null : e + "");
  for (var o = this._groups, i = o.length, r = 0; r < i; ++r)
    for (var a = o[r], l = a.length, s, u = 0; u < l; ++u)
      (s = a[u]) && _n(s, e, t, u, a, n || Yc(s, t));
  return new ze(o, this._parents, e, t);
}
Mt.prototype.interrupt = Fu;
Mt.prototype.transition = Xc;
const At = (e) => () => e;
function Uc(e, {
  sourceEvent: t,
  target: n,
  transform: o,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function Oe(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
Oe.prototype = {
  constructor: Oe,
  scale: function(e) {
    return e === 1 ? this : new Oe(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new Oe(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var gt = new Oe(1, 0, 0);
Oe.prototype;
function $n(e) {
  e.stopImmediatePropagation();
}
function pt(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Zc(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function Kc() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function si() {
  return this.__zoom || gt;
}
function Wc(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function qc() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function jc(e, t, n) {
  var o = e.invertX(t[0][0]) - n[0][0], i = e.invertX(t[1][0]) - n[1][0], r = e.invertY(t[0][1]) - n[0][1], a = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    i > o ? (o + i) / 2 : Math.min(0, o) || Math.max(0, i),
    a > r ? (r + a) / 2 : Math.min(0, r) || Math.max(0, a)
  );
}
function Qc() {
  var e = Zc, t = Kc, n = jc, o = Wc, i = qc, r = [0, 1 / 0], a = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], l = 250, s = Du, u = cn("start", "zoom", "end"), c, g, v, w = 500, f = 150, d = 0, _ = 10;
  function y(m) {
    m.property("__zoom", si).on("wheel.zoom", G, { passive: !1 }).on("mousedown.zoom", R).on("dblclick.zoom", I).filter(i).on("touchstart.zoom", H).on("touchmove.zoom", te).on("touchend.zoom touchcancel.zoom", q).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  y.transform = function(m, L, $, P) {
    var K = m.selection ? m.selection() : m;
    K.property("__zoom", si), m !== K ? C(m, L, $, P) : K.interrupt().each(function() {
      T(this, arguments).event(P).start().zoom(null, typeof L == "function" ? L.apply(this, arguments) : L).end();
    });
  }, y.scaleBy = function(m, L, $, P) {
    y.scaleTo(m, function() {
      var K = this.__zoom.k, Y = typeof L == "function" ? L.apply(this, arguments) : L;
      return K * Y;
    }, $, P);
  }, y.scaleTo = function(m, L, $, P) {
    y.transform(m, function() {
      var K = t.apply(this, arguments), Y = this.__zoom, D = $ == null ? x(K) : typeof $ == "function" ? $.apply(this, arguments) : $, U = Y.invert(D), j = typeof L == "function" ? L.apply(this, arguments) : L;
      return n(A(S(Y, j), D, U), K, a);
    }, $, P);
  }, y.translateBy = function(m, L, $, P) {
    y.transform(m, function() {
      return n(this.__zoom.translate(
        typeof L == "function" ? L.apply(this, arguments) : L,
        typeof $ == "function" ? $.apply(this, arguments) : $
      ), t.apply(this, arguments), a);
    }, null, P);
  }, y.translateTo = function(m, L, $, P, K) {
    y.transform(m, function() {
      var Y = t.apply(this, arguments), D = this.__zoom, U = P == null ? x(Y) : typeof P == "function" ? P.apply(this, arguments) : P;
      return n(gt.translate(U[0], U[1]).scale(D.k).translate(
        typeof L == "function" ? -L.apply(this, arguments) : -L,
        typeof $ == "function" ? -$.apply(this, arguments) : -$
      ), Y, a);
    }, P, K);
  };
  function S(m, L) {
    return L = Math.max(r[0], Math.min(r[1], L)), L === m.k ? m : new Oe(L, m.x, m.y);
  }
  function A(m, L, $) {
    var P = L[0] - $[0] * m.k, K = L[1] - $[1] * m.k;
    return P === m.x && K === m.y ? m : new Oe(m.k, P, K);
  }
  function x(m) {
    return [(+m[0][0] + +m[1][0]) / 2, (+m[0][1] + +m[1][1]) / 2];
  }
  function C(m, L, $, P) {
    m.on("start.zoom", function() {
      T(this, arguments).event(P).start();
    }).on("interrupt.zoom end.zoom", function() {
      T(this, arguments).event(P).end();
    }).tween("zoom", function() {
      var K = this, Y = arguments, D = T(K, Y).event(P), U = t.apply(K, Y), j = $ == null ? x(U) : typeof $ == "function" ? $.apply(K, Y) : $, ie = Math.max(U[1][0] - U[0][0], U[1][1] - U[0][1]), re = K.__zoom, B = typeof L == "function" ? L.apply(K, Y) : L, k = s(re.invert(j).concat(ie / re.k), B.invert(j).concat(ie / B.k));
      return function(F) {
        if (F === 1)
          F = B;
        else {
          var h = k(F), b = ie / h[2];
          F = new Oe(b, j[0] - h[0] * b, j[1] - h[1] * b);
        }
        D.zoom(null, F);
      };
    });
  }
  function T(m, L, $) {
    return !$ && m.__zooming || new p(m, L);
  }
  function p(m, L) {
    this.that = m, this.args = L, this.active = 0, this.sourceEvent = null, this.extent = t.apply(m, L), this.taps = 0;
  }
  p.prototype = {
    event: function(m) {
      return m && (this.sourceEvent = m), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(m, L) {
      return this.mouse && m !== "mouse" && (this.mouse[1] = L.invert(this.mouse[0])), this.touch0 && m !== "touch" && (this.touch0[1] = L.invert(this.touch0[0])), this.touch1 && m !== "touch" && (this.touch1[1] = L.invert(this.touch1[0])), this.that.__zoom = L, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(m) {
      var L = _e(this.that).datum();
      u.call(
        m,
        this.that,
        new Uc(m, {
          sourceEvent: this.sourceEvent,
          target: y,
          type: m,
          transform: this.that.__zoom,
          dispatch: u
        }),
        L
      );
    }
  };
  function G(m, ...L) {
    if (!e.apply(this, arguments))
      return;
    var $ = T(this, L).event(m), P = this.__zoom, K = Math.max(r[0], Math.min(r[1], P.k * Math.pow(2, o.apply(this, arguments)))), Y = Se(m);
    if ($.wheel)
      ($.mouse[0][0] !== Y[0] || $.mouse[0][1] !== Y[1]) && ($.mouse[1] = P.invert($.mouse[0] = Y)), clearTimeout($.wheel);
    else {
      if (P.k === K)
        return;
      $.mouse = [Y, P.invert(Y)], Lt(this), $.start();
    }
    pt(m), $.wheel = setTimeout(D, f), $.zoom("mouse", n(A(S(P, K), $.mouse[0], $.mouse[1]), $.extent, a));
    function D() {
      $.wheel = null, $.end();
    }
  }
  function R(m, ...L) {
    if (v || !e.apply(this, arguments))
      return;
    var $ = m.currentTarget, P = T(this, L, !0).event(m), K = _e(m.view).on("mousemove.zoom", j, !0).on("mouseup.zoom", ie, !0), Y = Se(m, $), D = m.clientX, U = m.clientY;
    Ki(m.view), $n(m), P.mouse = [Y, this.__zoom.invert(Y)], Lt(this), P.start();
    function j(re) {
      if (pt(re), !P.moved) {
        var B = re.clientX - D, k = re.clientY - U;
        P.moved = B * B + k * k > d;
      }
      P.event(re).zoom("mouse", n(A(P.that.__zoom, P.mouse[0] = Se(re, $), P.mouse[1]), P.extent, a));
    }
    function ie(re) {
      K.on("mousemove.zoom mouseup.zoom", null), Wi(re.view, P.moved), pt(re), P.event(re).end();
    }
  }
  function I(m, ...L) {
    if (e.apply(this, arguments)) {
      var $ = this.__zoom, P = Se(m.changedTouches ? m.changedTouches[0] : m, this), K = $.invert(P), Y = $.k * (m.shiftKey ? 0.5 : 2), D = n(A(S($, Y), P, K), t.apply(this, L), a);
      pt(m), l > 0 ? _e(this).transition().duration(l).call(C, D, P, m) : _e(this).call(y.transform, D, P, m);
    }
  }
  function H(m, ...L) {
    if (e.apply(this, arguments)) {
      var $ = m.touches, P = $.length, K = T(this, L, m.changedTouches.length === P).event(m), Y, D, U, j;
      for ($n(m), D = 0; D < P; ++D)
        U = $[D], j = Se(U, this), j = [j, this.__zoom.invert(j), U.identifier], K.touch0 ? !K.touch1 && K.touch0[2] !== j[2] && (K.touch1 = j, K.taps = 0) : (K.touch0 = j, Y = !0, K.taps = 1 + !!c);
      c && (c = clearTimeout(c)), Y && (K.taps < 2 && (g = j[0], c = setTimeout(function() {
        c = null;
      }, w)), Lt(this), K.start());
    }
  }
  function te(m, ...L) {
    if (this.__zooming) {
      var $ = T(this, L).event(m), P = m.changedTouches, K = P.length, Y, D, U, j;
      for (pt(m), Y = 0; Y < K; ++Y)
        D = P[Y], U = Se(D, this), $.touch0 && $.touch0[2] === D.identifier ? $.touch0[0] = U : $.touch1 && $.touch1[2] === D.identifier && ($.touch1[0] = U);
      if (D = $.that.__zoom, $.touch1) {
        var ie = $.touch0[0], re = $.touch0[1], B = $.touch1[0], k = $.touch1[1], F = (F = B[0] - ie[0]) * F + (F = B[1] - ie[1]) * F, h = (h = k[0] - re[0]) * h + (h = k[1] - re[1]) * h;
        D = S(D, Math.sqrt(F / h)), U = [(ie[0] + B[0]) / 2, (ie[1] + B[1]) / 2], j = [(re[0] + k[0]) / 2, (re[1] + k[1]) / 2];
      } else if ($.touch0)
        U = $.touch0[0], j = $.touch0[1];
      else
        return;
      $.zoom("touch", n(A(D, U, j), $.extent, a));
    }
  }
  function q(m, ...L) {
    if (this.__zooming) {
      var $ = T(this, L).event(m), P = m.changedTouches, K = P.length, Y, D;
      for ($n(m), v && clearTimeout(v), v = setTimeout(function() {
        v = null;
      }, w), Y = 0; Y < K; ++Y)
        D = P[Y], $.touch0 && $.touch0[2] === D.identifier ? delete $.touch0 : $.touch1 && $.touch1[2] === D.identifier && delete $.touch1;
      if ($.touch1 && !$.touch0 && ($.touch0 = $.touch1, delete $.touch1), $.touch0)
        $.touch0[1] = this.__zoom.invert($.touch0[0]);
      else if ($.end(), $.taps === 2 && (D = Se(D, this), Math.hypot(g[0] - D[0], g[1] - D[1]) < _)) {
        var U = _e(this).on("dblclick.zoom");
        U && U.apply(this, arguments);
      }
    }
  }
  return y.wheelDelta = function(m) {
    return arguments.length ? (o = typeof m == "function" ? m : At(+m), y) : o;
  }, y.filter = function(m) {
    return arguments.length ? (e = typeof m == "function" ? m : At(!!m), y) : e;
  }, y.touchable = function(m) {
    return arguments.length ? (i = typeof m == "function" ? m : At(!!m), y) : i;
  }, y.extent = function(m) {
    return arguments.length ? (t = typeof m == "function" ? m : At([[+m[0][0], +m[0][1]], [+m[1][0], +m[1][1]]]), y) : t;
  }, y.scaleExtent = function(m) {
    return arguments.length ? (r[0] = +m[0], r[1] = +m[1], y) : [r[0], r[1]];
  }, y.translateExtent = function(m) {
    return arguments.length ? (a[0][0] = +m[0][0], a[1][0] = +m[1][0], a[0][1] = +m[0][1], a[1][1] = +m[1][1], y) : [[a[0][0], a[0][1]], [a[1][0], a[1][1]]];
  }, y.constrain = function(m) {
    return arguments.length ? (n = m, y) : n;
  }, y.duration = function(m) {
    return arguments.length ? (l = +m, y) : l;
  }, y.interpolate = function(m) {
    return arguments.length ? (s = m, y) : s;
  }, y.on = function() {
    var m = u.on.apply(u, arguments);
    return m === u ? y : m;
  }, y.clickDistance = function(m) {
    return arguments.length ? (d = (m = +m) * m, y) : Math.sqrt(d);
  }, y.tapDistance = function(m) {
    return arguments.length ? (_ = +m, y) : _;
  }, y;
}
const kn = 0.1;
function Fe() {
}
const Jc = {
  zoomIn: Fe,
  zoomOut: Fe,
  zoomTo: Fe,
  fitView: Fe,
  setCenter: Fe,
  fitBounds: Fe,
  project: (e) => e,
  setTransform: Fe,
  getTransform: () => ({ x: 0, y: 0, zoom: 1 }),
  initialized: !1
}, ed = (e, t) => {
  const n = e, o = E(n, "nodes"), i = E(n, "d3Zoom"), r = E(n, "d3Selection"), a = E(n, "dimensions"), l = E(n, "translateExtent"), s = E(n, "minZoom"), u = E(n, "maxZoom"), c = E(n, "viewport"), g = E(n, "snapToGrid"), v = E(n, "snapGrid"), w = E(n, "hooks"), f = t, d = E(f, "getNodes"), _ = ne(!1);
  w.value.nodesInitialized.on(() => {
    _.value = !0;
  });
  const y = W(() => !!i.value && !!r.value && !!a.value.width && !!a.value.height && _.value);
  function S(x, C) {
    r.value && i.value && i.value.scaleBy(In(r.value, C), x);
  }
  function A(x, C, T, p) {
    const { x: G, y: R } = ro({ x: -x, y: -C }, l.value), I = gt.translate(-G, -R).scale(T);
    r.value && i.value && i.value.transform(In(r.value, p), I);
  }
  return W(() => y.value ? {
    initialized: !0,
    zoomIn: (x) => {
      S(1.2, x == null ? void 0 : x.duration);
    },
    zoomOut: (x) => {
      S(1 / 1.2, x == null ? void 0 : x.duration);
    },
    zoomTo: (x, C) => {
      r.value && i.value && i.value.scaleTo(In(r.value, C == null ? void 0 : C.duration), x);
    },
    setTransform: (x, C) => {
      A(x.x, x.y, x.zoom, C == null ? void 0 : C.duration);
    },
    getTransform: () => ({
      x: c.value.x,
      y: c.value.y,
      zoom: c.value.zoom
    }),
    fitView: (x = {
      padding: kn,
      includeHiddenNodes: !1,
      duration: 0
    }) => {
      if (!o.value.length)
        return;
      const C = (x.includeHiddenNodes ? o.value : d.value).filter((I) => {
        var q;
        const H = I.initialized && I.dimensions.width && I.dimensions.height;
        let te = !0;
        return (q = x.nodes) != null && q.length && (te = x.nodes.includes(I.id)), H && te;
      }), T = uo(C), { x: p, y: G, zoom: R } = Yt(
        T,
        a.value.width,
        a.value.height,
        x.minZoom ?? s.value,
        x.maxZoom ?? u.value,
        x.padding ?? kn,
        x.offset
      );
      A(p, G, R, x == null ? void 0 : x.duration);
    },
    setCenter: (x, C, T) => {
      const p = typeof (T == null ? void 0 : T.zoom) < "u" ? T.zoom : u.value, G = a.value.width / 2 - x * p, R = a.value.height / 2 - C * p;
      A(G, R, p, T == null ? void 0 : T.duration);
    },
    fitBounds: (x, C = { padding: kn }) => {
      const { x: T, y: p, zoom: G } = Yt(
        x,
        a.value.width,
        a.value.height,
        s.value,
        u.value,
        C.padding
      );
      A(T, p, G, C == null ? void 0 : C.duration);
    },
    project: (x) => so(x, c.value, g.value, v.value)
  } : Jc);
};
function In(e, t = 0) {
  return e.transition().duration(t);
}
function On(e, t) {
  if (t) {
    const n = e.position.x + e.dimensions.width - t.dimensions.width, o = e.position.y + e.dimensions.height - t.dimensions.height;
    if (n > 0 || o > 0 || e.position.x < 0 || e.position.y < 0) {
      let i = {};
      if (Pe(t.style) ? i = { ...t.style(t) } : t.style && (i = { ...t.style }), i.width = i.width ?? `${t.dimensions.width}px`, i.height = i.height ?? `${t.dimensions.height}px`, n > 0)
        if (Be(i.width)) {
          const r = Number(i.width.replace("px", ""));
          i.width = `${r + n}px`;
        } else
          i.width += n;
      if (o > 0)
        if (Be(i.height)) {
          const r = Number(i.height.replace("px", ""));
          i.height = `${r + o}px`;
        } else
          i.height += o;
      if (e.position.x < 0) {
        const r = Math.abs(e.position.x);
        if (t.position.x = t.position.x - r, Be(i.width)) {
          const a = Number(i.width.replace("px", ""));
          i.width = `${a + r}px`;
        } else
          i.width += r;
        e.position.x = 0;
      }
      if (e.position.y < 0) {
        const r = Math.abs(e.position.y);
        if (t.position.y = t.position.y - r, Be(i.height)) {
          const a = Number(i.height.replace("px", ""));
          i.height = `${a + r}px`;
        } else
          i.height += r;
        e.position.y = 0;
      }
      t.dimensions.width = Number(i.width.toString().replace("px", "")), t.dimensions.height = Number(i.height.toString().replace("px", "")), Pe(t.style) ? t.style = (r) => {
        const a = t.style;
        return {
          ...a(r),
          ...i
        };
      } : t.style = {
        ...t.style,
        ...i
      };
    }
  }
}
function en(e, t) {
  e.filter((i) => i.type === "add" || i.type === "remove").forEach((i) => {
    if (i.type === "add")
      t.findIndex((a) => a.id === i.item.id) === -1 && t.push(i.item);
    else if (i.type === "remove") {
      const r = t.findIndex((a) => a.id === i.id);
      r !== -1 && t.splice(r, 1);
    }
  });
  const o = t.map((i) => i.id);
  return t.forEach((i) => {
    var a, l;
    const r = e.filter((s) => s.id === i.id);
    for (const s of r)
      switch (s.type) {
        case "select":
          i.selected = s.selected;
          break;
        case "position":
          if (Re(i) && (typeof s.position < "u" && (i.position = s.position), typeof s.dragging < "u" && (i.dragging = s.dragging), i.expandParent && i.parentNode)) {
            const u = t[o.indexOf(i.parentNode)];
            u && Re(u) && On(i, u);
          }
          break;
        case "dimensions":
          if (Re(i)) {
            if (typeof s.dimensions < "u" && (i.dimensions = s.dimensions), typeof s.updateStyle < "u" && (i.style = {
              ...i.style || {},
              width: `${(a = s.dimensions) == null ? void 0 : a.width}px`,
              height: `${(l = s.dimensions) == null ? void 0 : l.height}px`
            }), typeof s.resizing < "u" && (i.resizing = s.resizing), i.expandParent && i.parentNode) {
              const u = t[o.indexOf(i.parentNode)];
              u && Re(u) && (u.initialized ? On(i, u) : Ke(() => {
                On(i, u);
              }));
            }
            i.initialized || (i.initialized = !0);
          }
          break;
      }
  }), t;
}
function Rd(e, t) {
  return en(e, t);
}
function Vd(e, t) {
  return en(e, t);
}
function ke(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function ui(e) {
  return {
    item: e,
    type: "add"
  };
}
function Tn(e) {
  return {
    id: e,
    type: "remove"
  };
}
function Pn(e, t) {
  return e.reduce(
    (n, o) => {
      let i = t.includes(o.id);
      de(o.selectable) && !o.selectable && (i = !1);
      const r = Re(o) ? "changedNodes" : "changedEdges";
      return !o.selected && i ? n[r].push(ke(o.id, !0)) : o.selected && !i && n[r].push(ke(o.id, !1)), n;
    },
    { changedNodes: [], changedEdges: [] }
  );
}
function td(e, t) {
  let n = !1;
  const o = ed(e, t);
  pe(() => o.value.initialized).toBe(!0).then(() => {
  });
  const i = W(() => e.nodes.map((h) => h.id)), r = W(() => e.edges.map((h) => h.id)), a = (h) => {
    const b = h ?? i.value ?? [];
    e.hooks.updateNodeInternals.trigger(b);
  }, l = (h) => e.nodes && !i.value.length ? e.nodes.find((b) => b.id === h) : e.nodes[i.value.indexOf(h)], s = (h) => e.edges && !r.value.length ? e.edges.find((b) => b.id === h) : e.edges[r.value.indexOf(h)], u = (h, b, z) => {
    const O = [];
    h.forEach((V) => {
      var N, Q;
      const Z = {
        id: V.id,
        type: "position",
        dragging: z,
        from: V.from
      };
      if (b && (Z.position = V.position, V.parentNode)) {
        const ee = l(V.parentNode);
        Z.position = {
          x: Z.position.x - (((N = ee == null ? void 0 : ee.computedPosition) == null ? void 0 : N.x) ?? 0),
          y: Z.position.y - (((Q = ee == null ? void 0 : ee.computedPosition) == null ? void 0 : Q.y) ?? 0)
        };
      }
      O.push(Z);
    }), O != null && O.length && e.hooks.nodesChange.trigger(O);
  }, c = (h) => {
    var V;
    if (!e.vueFlowRef)
      return;
    const b = e.vueFlowRef.querySelector(".vue-flow__transformationpane");
    if (!b)
      return;
    let z;
    if ((V = e.__experimentalFeatures) != null && V.nestedFlow) {
      let Z = [b], N = b, Q;
      for (; !Q && N; )
        N = N.parentElement, Q = N == null ? void 0 : N.classList.contains("vue-flow__transformationpane"), Q && (Z = [N, ...Z]);
      Z.forEach((ee) => {
        const se = window.getComputedStyle(ee), { m22: fe } = new window.DOMMatrixReadOnly(se.transform);
        z ? z *= fe : z = fe;
      });
    } else {
      const Z = window.getComputedStyle(b), { m22: N } = new window.DOMMatrixReadOnly(Z.transform);
      z = N;
    }
    const O = h.reduce((Z, N) => {
      const Q = l(N.id);
      if (Q) {
        const ee = nn(N.nodeElement);
        !!(ee.width && ee.height && (Q.dimensions.width !== ee.width || Q.dimensions.height !== ee.height || N.forceUpdate)) && (Q.handleBounds.source = Vo(".source", N.nodeElement, z), Q.handleBounds.target = Vo(".target", N.nodeElement, z), Q.dimensions = ee, Q.initialized = !0, Z.push({
          id: Q.id,
          type: "dimensions",
          dimensions: ee
        }));
      }
      return Z;
    }, []);
    e.fitViewOnInit && !n && (pe(() => o.value.initialized).toBe(!0).then(() => {
      o.value.fitView();
    }), n = !0), O.length && e.hooks.nodesChange.trigger(O);
  }, g = (h, b) => {
    const z = h.map((Z) => Z.id);
    let O, V = [];
    if (e.multiSelectionActive)
      O = z.map((Z) => ke(Z, b));
    else {
      const Z = Pn([...e.nodes, ...e.edges], z);
      O = Z.changedNodes, V = Z.changedEdges;
    }
    O.length && e.hooks.nodesChange.trigger(O), V.length && e.hooks.edgesChange.trigger(V);
  }, v = (h, b) => {
    const z = h.map((Z) => Z.id);
    let O = [], V;
    if (e.multiSelectionActive)
      V = z.map((Z) => ke(Z, b));
    else {
      const Z = Pn([...e.nodes, ...e.edges], z);
      O = Z.changedNodes, V = Z.changedEdges;
    }
    O.length && e.hooks.nodesChange.trigger(O), V.length && e.hooks.edgesChange.trigger(V);
  }, w = (h, b) => {
    const z = h.filter(Re), O = h.filter(wi), V = z.map((ee) => ee.id), Z = O.map((ee) => ee.id);
    let { changedNodes: N, changedEdges: Q } = Pn([...e.nodes, ...e.edges], [...V, ...Z]);
    e.multiSelectionActive && (N = V.map((ee) => ke(ee, b))), e.multiSelectionActive && (Q = Z.map((ee) => ke(ee, b))), N.length && e.hooks.nodesChange.trigger(N), Q.length && e.hooks.edgesChange.trigger(Q);
  }, f = (h) => {
    g(h, !0);
  }, d = (h) => {
    v(h, !0);
  }, _ = (h) => {
    w(h, !0);
  }, y = (h) => {
    if (!h.length)
      return g(h, !1);
    const z = h.map((O) => O.id).map((O) => ke(O, !1));
    z.length && e.hooks.nodesChange.trigger(z);
  }, S = (h) => {
    if (!h.length)
      return v(h, !1);
    const z = h.map((O) => O.id).map((O) => ke(O, !1));
    z.length && e.hooks.edgesChange.trigger(z);
  }, A = (h) => {
    if (!h || !h.length)
      return w([], !1);
    const { changedNodes: b, changedEdges: z } = h.reduce(
      (O, V) => {
        const Z = ke(V.id, !1);
        return Re(V) ? O.changedNodes.push(Z) : O.changedEdges.push(Z), O;
      },
      { changedNodes: [], changedEdges: [] }
    );
    b.length && e.hooks.nodesChange.trigger(b), z.length && e.hooks.edgesChange.trigger(z);
  }, x = (h) => {
    var b;
    (b = e.d3Zoom) == null || b.scaleExtent([h, e.maxZoom]), e.minZoom = h;
  }, C = (h) => {
    var b;
    (b = e.d3Zoom) == null || b.scaleExtent([e.minZoom, h]), e.maxZoom = h;
  }, T = (h) => {
    var b;
    (b = e.d3Zoom) == null || b.translateExtent(h), e.translateExtent = h;
  }, p = async (h) => {
    e.nodeExtent = h;
    const b = t.getNodes.value.filter((z) => z.initialized).map((z) => z.id);
    a(b);
  }, G = (h) => {
    e.nodesDraggable = h, e.nodesConnectable = h, e.elementsSelectable = h;
  }, R = (h) => {
    const b = h instanceof Function ? h(e.nodes) : h;
    !e.initialized && !b.length || (e.nodes = To(b, e.nodes, l, e.hooks.error.trigger));
  }, I = (h) => {
    const b = h instanceof Function ? h(e.edges) : h;
    if (!e.initialized && !b.length)
      return;
    const z = e.isValidConnection ? b.filter(
      (O) => e.isValidConnection(O, {
        edges: e.edges,
        sourceNode: l(O.source),
        targetNode: l(O.target)
      })
    ) : b;
    e.edges = z.reduce((O, V) => {
      const Z = l(V.source), N = l(V.target), Q = !Z || typeof Z > "u", ee = !N || typeof N > "u";
      if (Q && ee ? e.hooks.error.trigger(new ve(he.EDGE_SOURCE_TARGET_MISSING, V.id, V.source, V.target)) : (Q && e.hooks.error.trigger(new ve(he.EDGE_SOURCE_MISSING, V.id, V.source)), ee && e.hooks.error.trigger(new ve(he.EDGE_TARGET_MISSING, V.id, V.target))), Q || ee)
        return O;
      const se = t.getEdge.value(V.id);
      return O.push({
        ...lo(V, Object.assign({}, se, e.defaultEdgeOptions)),
        sourceNode: Z,
        targetNode: N
      }), O;
    }, []);
  }, H = (h) => {
    const b = h instanceof Function ? h([...e.nodes, ...e.edges]) : h;
    !e.initialized && !b.length || (R(b.filter(ao)), I(b.filter(De)));
  }, te = (h) => {
    const b = h instanceof Function ? h(e.nodes) : h, O = To(b, e.nodes, l, e.hooks.error.trigger).map(ui);
    O.length && e.hooks.nodesChange.trigger(O);
  }, q = (h) => {
    const b = h instanceof Function ? h(e.edges) : h, O = (e.isValidConnection ? b.filter(
      (V) => e.isValidConnection(V, {
        edges: e.edges,
        sourceNode: l(V.source),
        targetNode: l(V.target)
      })
    ) : b).reduce((V, Z) => {
      const N = ga(
        {
          ...Z,
          ...e.defaultEdgeOptions
        },
        e.edges,
        e.hooks.error.trigger
      );
      if (N) {
        const Q = l(N.source), ee = l(N.target), se = !Q || typeof Q > "u", fe = !ee || typeof ee > "u";
        if (se && fe ? e.hooks.error.trigger(new ve(he.EDGE_SOURCE_TARGET_MISSING, N.id, N.source, N.target)) : (se && e.hooks.error.trigger(new ve(he.EDGE_SOURCE_MISSING, N.id, N.source)), fe && e.hooks.error.trigger(new ve(he.EDGE_TARGET_MISSING, N.id, N.target))), se || fe)
          return V;
        V.push(
          ui({
            ...N,
            sourceNode: Q,
            targetNode: ee
          })
        );
      }
      return V;
    }, []);
    O.length && e.hooks.edgesChange.trigger(O);
  }, m = (h, b = !0) => {
    const z = h instanceof Function ? h(e.nodes) : h, O = [], V = [];
    z.forEach((Z) => {
      const N = typeof Z == "string" ? l(Z) : Z;
      if (!(de(N.deletable) && !N.deletable) && (O.push(Tn(N.id)), b)) {
        const Q = rn([N], e.edges).filter((ee) => de(ee.deletable) ? ee.deletable : !0);
        V.push(...Q.map((ee) => Tn(ee.id)));
      }
    }), V.length && e.hooks.edgesChange.trigger(V), O.length && e.hooks.nodesChange.trigger(O);
  }, L = (h) => {
    const b = h instanceof Function ? h(e.edges) : h, z = [];
    b.forEach((O) => {
      const V = typeof O == "string" ? s(O) : O;
      de(V.deletable) && !V.deletable || z.push(Tn(typeof O == "string" ? O : O.id));
    }), e.hooks.edgesChange.trigger(z);
  }, $ = (h, b, z = !0) => va(h, b, e.edges, s, z, e.hooks.error.trigger), P = (h) => en(h, e.nodes), K = (h) => en(h, e.edges), Y = (h, b, z, O = !1) => {
    O ? e.connectionClickStartHandle = h : e.connectionStartHandle = h, e.connectionEndHandle = null, e.connectionStatus = null, b && (e.connectionPosition = b);
  }, D = (h, b = null, z = null) => {
    e.connectionStartHandle && (e.connectionPosition = h, e.connectionEndHandle = b, e.connectionStatus = z);
  }, U = (h, b) => {
    e.connectionPosition = { x: NaN, y: NaN }, e.connectionStatus = null, b ? e.connectionClickStartHandle = null : e.connectionStartHandle = null;
  }, j = (h) => {
    const b = ca(h), z = b ? null : l(h.id);
    return !b && !z ? [null, null, b] : [b ? h : Io(z), z, b];
  }, ie = (h, b = !0, z) => {
    const [O, V, Z] = j(h);
    return O ? (z || e.nodes).filter((N) => {
      if (!Z && (N.id === V.id || !N.computedPosition))
        return !1;
      const Q = Io(N), ee = Ln(Q, O);
      return b && ee > 0 || ee >= Number(h.width) * Number(h.height);
    }) : [];
  }, re = (h, b, z = !0) => {
    const [O] = j(h);
    if (!O)
      return !1;
    const V = Ln(O, b);
    return z && V > 0 || V >= Number(h.width) * Number(h.height);
  }, B = (h) => {
    const { viewport: b, dimensions: z, d3Zoom: O, d3Selection: V, translateExtent: Z } = e;
    if (!O || !V || !h.x && !h.y)
      return;
    const N = gt.translate(b.x + h.x, b.y + h.y).scale(b.zoom), Q = [
      [0, 0],
      [z.width, z.height]
    ], ee = O.constrain()(N, Q, Z);
    O.transform(V, ee);
  }, k = (h) => {
    const b = h instanceof Function ? h(e) : h, z = [
      "modelValue",
      "nodes",
      "edges",
      "maxZoom",
      "minZoom",
      "translateExtent",
      "nodeExtent",
      "hooks"
    ], O = b.modelValue || b.nodes || b.edges ? [] : void 0;
    O && (b.modelValue && O.push(...b.modelValue), b.nodes && O.push(...b.nodes), b.edges && O.push(...b.edges), H(O));
    const V = () => {
      typeof b.maxZoom < "u" && C(b.maxZoom), typeof b.minZoom < "u" && x(b.minZoom), typeof b.translateExtent < "u" && T(b.translateExtent), typeof b.nodeExtent < "u" && p(b.nodeExtent);
    };
    Object.keys(b).forEach((Z) => {
      const N = b[Z];
      !z.includes(Z) && de(N) && (e[Z] = N);
    }), e.d3Zoom ? V() : pe(() => e.d3Zoom).not.toBeUndefined().then(V), e.initialized || (e.initialized = !0);
  };
  return {
    updateNodePositions: u,
    updateNodeDimensions: c,
    setElements: H,
    setNodes: R,
    setEdges: I,
    addNodes: te,
    addEdges: q,
    removeNodes: m,
    removeEdges: L,
    findNode: l,
    findEdge: s,
    updateEdge: $,
    applyEdgeChanges: K,
    applyNodeChanges: P,
    addSelectedElements: _,
    addSelectedNodes: f,
    addSelectedEdges: d,
    setMinZoom: x,
    setMaxZoom: C,
    setTranslateExtent: T,
    setNodeExtent: p,
    removeSelectedElements: A,
    removeSelectedNodes: y,
    removeSelectedEdges: S,
    startConnection: Y,
    updateConnection: D,
    endConnection: U,
    setInteractive: G,
    setState: k,
    getIntersectingNodes: ie,
    isNodeIntersecting: re,
    panBy: B,
    fitView: async (h = { padding: 0.1 }) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.fitView(h);
    },
    zoomIn: async (h) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.zoomIn(h);
    },
    zoomOut: async (h) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.zoomOut(h);
    },
    zoomTo: async (h, b) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.zoomTo(h, b);
    },
    setTransform: async (h, b) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.setTransform(h, b);
    },
    getTransform: () => o.value.getTransform(),
    setCenter: async (h, b, z) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.setCenter(h, b, z);
    },
    fitBounds: async (h, b) => {
      await pe(() => o.value.initialized).toBe(!0), o.value.fitBounds(h, b);
    },
    project: (h) => o.value.project(h),
    toObject: () => JSON.parse(
      JSON.stringify({
        nodes: e.nodes.map((h) => {
          const {
            computedPosition: b,
            handleBounds: z,
            selected: O,
            dimensions: V,
            isParent: Z,
            resizing: N,
            dragging: Q,
            initialized: ee,
            ...se
          } = h;
          return se;
        }),
        edges: e.edges.map((h) => {
          const { selected: b, sourceNode: z, targetNode: O, ...V } = h;
          return V;
        }),
        position: [e.viewport.x, e.viewport.y],
        zoom: e.viewport.zoom
      })
    ),
    updateNodeInternals: a,
    $reset: () => {
      e.edges = [], e.nodes = [], k(rr());
    },
    $destroy: () => {
    }
  };
}
class tt {
  constructor() {
    this.currentId = 0, this.flows = /* @__PURE__ */ new Map();
  }
  static getInstance() {
    return tt.instance || (tt.instance = new tt()), tt.instance;
  }
  set(t, n) {
    return this.flows.set(t, n);
  }
  get(t) {
    return this.flows.get(t);
  }
  remove(t) {
    return this.flows.delete(t);
  }
  create(t, n) {
    const o = rr(n), i = $r(o), r = su(i), a = td(i, r), l = {};
    Object.entries(i.hooks).forEach(([c, g]) => {
      const v = `on${c.charAt(0).toUpperCase() + c.slice(1)}`;
      l[v] = g.on;
    });
    const s = {};
    Object.entries(i.hooks).forEach(([c, g]) => {
      s[c] = g.trigger;
    }), a.setState(i);
    const u = {
      ...l,
      ...r,
      ...a,
      ...kr(i),
      emits: s,
      id: t,
      $destroy: () => {
        this.remove(t);
      }
    };
    return this.set(t, u), u;
  }
  getId() {
    return `vue-flow-${this.currentId++}`;
  }
}
const ce = (e) => {
  const t = tt.getInstance(), n = di(), o = e == null ? void 0 : e.id, i = (n == null ? void 0 : n.vueFlowId) || o;
  let r, a = !1;
  if (n) {
    const l = He(Po, null);
    typeof l < "u" && l !== null && (r = l);
  }
  if (r || i && (r = t.get(i)), !r || r && o && o !== r.id) {
    const l = o ?? t.getId();
    r = t.create(l, e), n && (a = !0);
  } else
    e && r.setState(e);
  return n && (lt(Po, r), n.vueFlowId = r.id, a && ht(() => {
    if (r) {
      const l = t.get(r.id);
      l ? l.$destroy() : wt(`No store instance found for id ${r.id} in storage.`);
    }
  })), r;
};
function nd(e, t, n) {
  const o = fi();
  return o.run(() => {
    [
      () => {
        o.run(() => {
          let f, d, _ = !!(n.nodes.value.length || n.edges.value.length);
          f = et([e.modelValue, () => {
            var y, S;
            return (S = (y = e.modelValue) == null ? void 0 : y.value) == null ? void 0 : S.length;
          }], ([y]) => {
            y && Array.isArray(y) && (d == null || d.pause(), n.setElements(y), !d && !_ && y.length ? _ = !0 : d == null || d.resume());
          }), d = et(
            [n.nodes, n.edges, () => n.edges.value.length, () => n.nodes.value.length],
            ([y, S]) => {
              var A;
              (A = e.modelValue) != null && A.value && Array.isArray(e.modelValue.value) && (f == null || f.pause(), e.modelValue.value = [...y, ...S], Ke(() => {
                f == null || f.resume();
              }));
            },
            { immediate: _ }
          ), Bt(() => {
            f == null || f.stop(), d == null || d.stop();
          });
        });
      },
      () => {
        o.run(() => {
          let f, d, _ = !!n.nodes.value.length;
          f = et([e.nodes, () => {
            var y, S;
            return (S = (y = e.nodes) == null ? void 0 : y.value) == null ? void 0 : S.length;
          }], ([y]) => {
            y && Array.isArray(y) && (d == null || d.pause(), n.setNodes(y), !d && !_ && y.length ? _ = !0 : d == null || d.resume());
          }), d = et(
            [n.nodes, () => n.nodes.value.length],
            ([y]) => {
              var S;
              (S = e.nodes) != null && S.value && Array.isArray(e.nodes.value) && (f == null || f.pause(), e.nodes.value = [...y], Ke(() => {
                f == null || f.resume();
              }));
            },
            { immediate: _ }
          ), Bt(() => {
            f == null || f.stop(), d == null || d.stop();
          });
        });
      },
      () => {
        o.run(() => {
          let f, d, _ = !!n.edges.value.length;
          f = et([e.edges, () => {
            var y, S;
            return (S = (y = e.edges) == null ? void 0 : y.value) == null ? void 0 : S.length;
          }], ([y]) => {
            y && Array.isArray(y) && (d == null || d.pause(), n.setEdges(y), !d && !_ && y.length ? _ = !0 : d == null || d.resume());
          }), d = et(
            [n.edges, () => n.edges.value.length],
            ([y]) => {
              var S;
              (S = e.edges) != null && S.value && Array.isArray(e.edges.value) && (f == null || f.pause(), e.edges.value = [...y], Ke(() => {
                f == null || f.resume();
              }));
            },
            { immediate: _ }
          ), Bt(() => {
            f == null || f.stop(), d == null || d.stop();
          });
        });
      },
      () => {
        o.run(() => {
          ue(
            () => t.minZoom,
            () => {
              t.minZoom && de(t.minZoom) && n.setMinZoom(t.minZoom);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ue(
            () => t.maxZoom,
            () => {
              t.maxZoom && de(t.maxZoom) && n.setMaxZoom(t.maxZoom);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ue(
            () => t.translateExtent,
            () => {
              t.translateExtent && de(t.translateExtent) && n.setTranslateExtent(t.translateExtent);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ue(
            () => t.nodeExtent,
            () => {
              t.nodeExtent && de(t.nodeExtent) && n.setNodeExtent(t.nodeExtent);
            }
          );
        });
      },
      () => {
        o.run(() => {
          ue(
            () => t.applyDefault,
            () => {
              de(t.applyDefault) && (n.applyDefault.value = t.applyDefault);
            }
          ), ue(
            n.applyDefault,
            (f, d, _) => {
              n.applyDefault.value ? (n.onNodesChange(n.applyNodeChanges), n.onEdgesChange(n.applyEdgeChanges)) : (n.hooks.value.nodesChange.off(n.applyNodeChanges), n.hooks.value.edgesChange.off(n.applyEdgeChanges)), _(() => {
                n.hooks.value.nodesChange.off(n.applyNodeChanges), n.hooks.value.edgesChange.off(n.applyEdgeChanges);
              });
            },
            { immediate: !0 }
          );
        });
      },
      () => {
        o.run(() => {
          const f = async (d) => {
            let _ = d;
            Pe(t.autoConnect) && (_ = await t.autoConnect(d)), _ !== !1 && n.addEdges([_]);
          };
          ue(
            () => t.autoConnect,
            () => {
              de(t.autoConnect) && (n.autoConnect.value = t.autoConnect);
            }
          ), ue(
            n.autoConnect,
            (d, _, y) => {
              d ? n.onConnect(f) : n.hooks.value.connect.off(f), y(() => {
                n.hooks.value.connect.off(f);
              });
            },
            { immediate: !0 }
          );
        });
      },
      () => {
        const f = [
          "id",
          "modelValue",
          "translateExtent",
          "nodeExtent",
          "edges",
          "nodes",
          "maxZoom",
          "minZoom",
          "applyDefault",
          "autoConnect"
        ];
        Object.keys(t).forEach((d) => {
          if (!f.includes(d)) {
            const _ = E(t, d), y = n[d];
            o.run(() => {
              ue(
                _,
                (S) => {
                  de(S) && (y.value = S);
                },
                { flush: "pre" }
              );
            });
          }
        });
      }
    ].forEach((f) => f());
  }), () => o.stop();
}
function ci(e, t) {
  return {
    x: e.clientX - t.left,
    y: e.clientY - t.top
  };
}
const od = {
  name: "Pane",
  compatConfig: { MODE: 3 }
}, id = /* @__PURE__ */ ge({
  ...od,
  props: {
    isSelecting: { type: Boolean }
  },
  setup(e) {
    const {
      id: t,
      vueFlowRef: n,
      getNodes: o,
      getEdges: i,
      viewport: r,
      emits: a,
      userSelectionActive: l,
      removeSelectedElements: s,
      panOnDrag: u,
      userSelectionRect: c,
      elementsSelectable: g,
      nodesSelectionActive: v,
      addSelectedElements: w,
      getSelectedEdges: f,
      getSelectedNodes: d,
      removeNodes: _,
      removeEdges: y,
      selectionMode: S,
      deleteKeyCode: A,
      multiSelectionKeyCode: x,
      multiSelectionActive: C
    } = ce(), T = ne(null), p = ne(0), G = ne(0), R = ne(), I = W(() => g.value && (e.isSelecting || l.value));
    _t(A, (D) => {
      if (!D)
        return;
      const U = o.value.reduce((j, ie) => ((!ie.selected && ie.parentNode && j.find((re) => re.id === ie.parentNode) || ie.selected) && j.push(ie), j), []);
      (U || f.value) && (f.value.length > 0 && y(f.value), U.length > 0 && _(U), v.value = !1, s());
    }), _t(x, (D) => {
      C.value = D;
    });
    function H() {
      l.value = !1, c.value = null, p.value = 0, G.value = 0;
    }
    function te(D) {
      D.target !== T.value || I.value || (a.paneClick(D), s(), v.value = !1);
    }
    function q(D) {
      var U;
      if (D.target === T.value) {
        if (Array.isArray(u.value) && ((U = u.value) != null && U.includes(2))) {
          D.preventDefault();
          return;
        }
        a.paneContextMenu(D);
      }
    }
    function m(D) {
      D.target === T.value && a.paneScroll(D);
    }
    function L(D) {
      if (R.value = n.value.getBoundingClientRect(), !I.value || !g || !e.isSelecting || D.button !== 0 || D.target !== T.value || !R.value)
        return;
      const { x: U, y: j } = ci(D, R.value);
      s(), c.value = {
        width: 0,
        height: 0,
        startX: U,
        startY: j,
        x: U,
        y: j
      }, l.value = !0, a.selectionStart(D);
    }
    function $(D) {
      if (!e.isSelecting || !R.value || !c.value)
        return;
      if (!I.value)
        return a.paneMouseMove(D);
      l.value || (l.value = !0), v.value && (v.value = !1);
      const U = ci(D, R.value), j = c.value.startX ?? 0, ie = c.value.startY ?? 0, re = {
        ...c.value,
        x: U.x < j ? U.x : j,
        y: U.y < ie ? U.y : ie,
        width: Math.abs(U.x - j),
        height: Math.abs(U.y - ie)
      }, B = Ci(
        o.value,
        c.value,
        r.value,
        S.value === co.Partial
      ), k = rn(B, i.value);
      p.value = B.length, G.value = k.length, c.value = re, w([...B, ...k]);
    }
    function P(D) {
      I.value && D.button === 0 && (!l.value && c.value && D.target === T.value && te(D), v.value = p.value > 0, H(), a.selectionEnd(D));
    }
    function K(D) {
      var U;
      if (!I.value)
        return a.paneMouseLeave(D);
      l.value && (v.value = p.value > 0, (U = a.selectionEnd) == null || U.call(a, D)), H();
    }
    function Y(D) {
      I.value || a.paneMouseEnter(D);
    }
    return (D, U) => (oe(), ae("div", {
      ref_key: "container",
      ref: T,
      key: `pane-${M(t)}`,
      class: qe(["vue-flow__pane vue-flow__container", [{ selection: e.isSelecting }]]),
      onClick: te,
      onContextmenu: q,
      onWheelPassive: m,
      onMouseenter: Y,
      onMousedown: L,
      onMousemove: $,
      onMouseup: P,
      onMouseleave: K
    }, [
      ye(D.$slots, "default"),
      M(l) && M(c) ? (oe(), Te(iu, { key: 0 })) : be("", !0),
      M(v) && M(d).length ? (oe(), Te(nu, { key: 1 })) : be("", !0)
    ], 34));
  }
}), rd = { class: "vue-flow__nodes vue-flow__container" }, ad = {
  name: "Nodes",
  compatConfig: { MODE: 3 }
}, ld = /* @__PURE__ */ ge({
  ...ad,
  setup(e) {
    const t = He(an), n = ce(), o = E(n, "nodesDraggable"), i = E(n, "nodesFocusable"), r = E(n, "elementsSelectable"), a = E(n, "nodesConnectable"), l = E(n, "getNodes"), s = E(n, "getNodesInitialized"), u = E(n, "getNodeTypes"), c = E(n, "updateNodeDimensions"), g = E(n, "emits");
    let v = ne();
    pe(() => l.value.length > 0 && s.value.length === l.value.length).toBe(!0).then(() => {
      Ke(() => {
        g.value.nodesInitialized(s.value);
      });
    }), Ve(() => {
      v.value = new ResizeObserver((S) => {
        const A = S.map((x) => ({
          id: x.target.getAttribute("data-id"),
          nodeElement: x.target,
          forceUpdate: !0
        }));
        c.value(A);
      });
    }), hi(() => {
      var S;
      return (S = v.value) == null ? void 0 : S.disconnect();
    });
    function w(S) {
      return typeof S > "u" ? o.value : S;
    }
    function f(S) {
      return typeof S > "u" ? r.value : S;
    }
    function d(S) {
      return typeof S > "u" ? a.value : S;
    }
    function _(S) {
      return typeof S > "u" ? i.value : S;
    }
    function y(S, A) {
      const x = S || "default";
      let C = A ?? u.value[x];
      const T = tn();
      if (typeof C == "string" && T) {
        const G = Object.keys(T.appContext.components);
        G && G.includes(x) && (C = pi(x, !1));
      }
      if (typeof C != "string")
        return C;
      const p = t == null ? void 0 : t[`node-${x}`];
      return p || (g.value.error(new ve(he.NODE_TYPE_MISSING, C)), !1);
    }
    return (S, A) => (oe(), ae("div", rd, [
      M(v) ? (oe(!0), ae(Ne, { key: 0 }, ut(M(l), (x) => (oe(), Te(M(ks), {
        id: x.id,
        key: x.id,
        "resize-observer": M(v),
        type: y(x.type, x.template),
        name: x.type || "default",
        draggable: w(x.draggable),
        selectable: f(x.selectable),
        connectable: d(x.connectable),
        focusable: _(x.focusable),
        node: x
      }, null, 8, ["id", "resize-observer", "type", "name", "draggable", "selectable", "connectable", "focusable", "node"]))), 128)) : be("", !0)
    ]));
  }
}), sd = ["id", "markerWidth", "markerHeight", "markerUnits", "orient"], ud = ["stroke", "stroke-width", "fill"], cd = ["stroke", "stroke-width"], dd = {
  name: "MarkerType",
  compatConfig: { MODE: 3 }
}, fd = /* @__PURE__ */ ge({
  ...dd,
  props: {
    id: null,
    type: null,
    color: { default: "none" },
    width: { default: 12.5 },
    height: { default: 12.5 },
    markerUnits: { default: "strokeWidth" },
    orient: { default: "auto-start-reverse" },
    strokeWidth: { default: 1 }
  },
  setup(e) {
    return (t, n) => (oe(), ae("marker", {
      id: e.id,
      class: "vue-flow__arrowhead",
      viewBox: "-10 -10 20 20",
      refX: "0",
      refY: "0",
      markerWidth: `${e.width}`,
      markerHeight: `${e.height}`,
      markerUnits: e.markerUnits,
      orient: e.orient
    }, [
      e.type === M(Fn).ArrowClosed ? (oe(), ae("polyline", {
        key: 0,
        stroke: e.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": e.strokeWidth,
        fill: e.color,
        points: "-5,-4 0,0 -5,4 -5,-4"
      }, null, 8, ud)) : be("", !0),
      e.type === M(Fn).Arrow ? (oe(), ae("polyline", {
        key: 1,
        stroke: e.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round",
        "stroke-width": e.strokeWidth,
        fill: "none",
        points: "-5,-4 0,0 -5,4"
      }, null, 8, cd)) : be("", !0)
    ], 8, sd));
  }
}), hd = {
  name: "MarkerDefinitions",
  compatConfig: { MODE: 3 }
}, gd = /* @__PURE__ */ ge({
  ...hd,
  setup(e) {
    const t = ce(), n = E(t, "id"), o = E(t, "edges"), i = E(t, "connectionLineOptions"), r = E(t, "defaultMarkerColor"), a = W(() => {
      const l = [], s = [], u = (c) => {
        if (c) {
          const g = Ue(c, n.value);
          l.includes(g) || (typeof c == "object" ? s.push({ ...c, id: g, color: c.color || r.value }) : s.push({ id: g, color: r.value, type: c }), l.push(g));
        }
      };
      return [i.value.markerEnd, i.value.markerStart].forEach(u), o.value.reduce((c, g) => ([g.markerStart, g.markerEnd].forEach(u), c.sort((v, w) => v.id.localeCompare(w.id))), s), s;
    });
    return (l, s) => (oe(), ae("defs", null, [
      (oe(!0), ae(Ne, null, ut(M(a), (u) => (oe(), Te(fd, {
        id: u.id,
        key: u.id,
        type: u.type,
        color: u.color,
        width: u.width,
        height: u.height,
        markerUnits: u.markerUnits,
        "stroke-width": u.strokeWidth,
        orient: u.orient
      }, null, 8, ["id", "type", "color", "width", "height", "markerUnits", "stroke-width", "orient"]))), 128))
    ]));
  }
}), vd = {
  key: 0,
  class: "vue-flow__edges vue-flow__connectionline vue-flow__container"
}, pd = {
  name: "Edges",
  compatConfig: { MODE: 3 }
}, md = /* @__PURE__ */ ge({
  ...pd,
  setup(e) {
    const t = He(an), n = ce(), o = E(n, "connectionStartHandle"), i = E(n, "nodesConnectable"), r = E(n, "edgesUpdatable"), a = E(n, "edgesFocusable"), l = E(n, "elementsSelectable"), s = E(n, "getSelectedNodes"), u = E(n, "findNode"), c = E(n, "getEdges"), g = E(n, "getNodesInitialized"), v = E(n, "getEdgeTypes"), w = E(n, "elevateEdgesOnSelect"), f = E(n, "dimensions"), d = E(n, "emits"), _ = wn(
      () => {
        var p;
        return (p = o.value) == null ? void 0 : p.nodeId;
      },
      () => {
        var p;
        return (p = o.value) != null && p.nodeId ? u.value(o.value.nodeId) : !1;
      }
    ), y = wn(
      () => {
        var p;
        return (p = o.value) == null ? void 0 : p.nodeId;
      },
      () => {
        var p, G;
        return !!(_.value && (typeof _.value.connectable > "u" ? i.value : _.value.connectable) && ((p = o.value) != null && p.nodeId) && ((G = o.value) != null && G.type));
      }
    ), S = wn(
      [
        () => c.value.map((p) => p.zIndex),
        () => w.value ? [s.value.length] : [0],
        () => w.value ? g.value.map((p) => p.computedPosition.z) : []
      ],
      () => _a(c.value, u.value, w.value)
    );
    function A(p) {
      return typeof p > "u" ? l.value : p;
    }
    function x(p) {
      return typeof p > "u" ? r.value : p;
    }
    function C(p) {
      return typeof p > "u" ? a.value : p;
    }
    function T(p, G) {
      const R = p || "default";
      let I = G ?? v.value[R];
      const H = tn();
      if (typeof I == "string" && H) {
        const q = Object.keys(H.appContext.components);
        q && q.includes(R) && (I = pi(R, !1));
      }
      if (I && typeof I != "string")
        return I;
      const te = t == null ? void 0 : t[`edge-${R}`];
      return te || (d.value.error(new ve(he.EDGE_TYPE_MISSING, I)), !1);
    }
    return (p, G) => M(f).width && M(f).height ? (oe(), ae(Ne, { key: 0 }, [
      (oe(!0), ae(Ne, null, ut(M(S), (R) => (oe(), ae("svg", {
        key: R.level,
        class: "vue-flow__edges vue-flow__container",
        style: Le(`z-index: ${R.level}`)
      }, [
        R.isMaxLevel ? (oe(), Te(gd, { key: 0 })) : be("", !0),
        st("g", null, [
          (oe(!0), ae(Ne, null, ut(R.edges, (I) => (oe(), Te(M(Zs), {
            id: I.id,
            key: I.id,
            edge: I,
            type: T(I.type, I.template),
            name: I.type || "default",
            selectable: A(I.selectable),
            updatable: x(I.updatable),
            focusable: C(I.focusable)
          }, null, 8, ["id", "edge", "type", "name", "selectable", "updatable", "focusable"]))), 128))
        ])
      ], 4))), 128)),
      M(y) && M(_) ? (oe(), ae("svg", vd, [
        je(Js, { "source-node": M(_) }, null, 8, ["source-node"])
      ])) : be("", !0)
    ], 64)) : be("", !0);
  }
}), yd = /* @__PURE__ */ st("div", { class: "vue-flow__edge-labels" }, null, -1), xd = {
  name: "Transform",
  compatConfig: { MODE: 3 }
}, _d = /* @__PURE__ */ ge({
  ...xd,
  setup(e) {
    const { id: t, viewport: n, emits: o, d3Zoom: i, d3Selection: r, dimensions: a, ...l } = ce(), s = ne(!to);
    return pe(() => i.value && r.value && a.value.width > 0 && a.value.height > 0).toBeTruthy().then(() => {
      o.paneReady({
        id: t,
        viewport: n,
        emits: o,
        d3Zoom: i,
        d3Selection: r,
        dimensions: a,
        ...l
      }), setTimeout(() => {
        s.value = !0;
      }, 0);
    }), (u, c) => (oe(), ae("div", {
      key: `transform-${M(t)}`,
      class: "vue-flow__transformationpane vue-flow__container",
      style: Le({
        transform: `translate(${M(n).x}px,${M(n).y}px) scale(${M(n).zoom})`,
        opacity: M(s) ? void 0 : 0
      })
    }, [
      je(md),
      yd,
      je(ld),
      ye(u.$slots, "default")
    ], 4));
  }
}), wd = {
  name: "Viewport",
  compatConfig: { MODE: 3 }
}, bd = /* @__PURE__ */ ge({
  ...wd,
  setup(e) {
    const t = ce(), n = E(t, "id"), o = E(t, "minZoom"), i = E(t, "maxZoom"), r = E(t, "defaultViewport"), a = E(t, "translateExtent"), l = E(t, "dimensions"), s = E(t, "zoomActivationKeyCode"), u = E(t, "selectionKeyCode"), c = E(t, "panActivationKeyCode"), g = E(t, "panOnScroll"), v = E(t, "panOnScrollMode"), w = E(t, "panOnScrollSpeed"), f = E(t, "panOnDrag"), d = E(t, "zoomOnDoubleClick"), _ = E(t, "zoomOnPinch"), y = E(t, "zoomOnScroll"), S = E(t, "preventScrolling"), A = E(t, "noWheelClassName"), x = E(t, "noPanClassName"), C = E(t, "setState"), T = E(t, "emits"), p = E(t, "connectionStartHandle"), G = E(t, "userSelectionActive"), R = E(t, "paneDragging"), I = ne();
    let H = ne(!1), te = ne(!1), q = ne(!1), m = ne(0);
    const L = _t(c.value), $ = W(() => !!p.value), P = W(() => !H.value && f.value && L.value), K = W(
      () => u.value !== !0 && H.value || u.value === !0 && P.value !== !0
    );
    let Y = ne({
      x: 0,
      y: 0,
      zoom: 0
    });
    Ve(() => {
      ta(I, ie);
      const B = io();
      oo(B, "resize", ie);
    }), Ve(() => {
      const B = I.value, k = B.getBoundingClientRect(), F = Qc().scaleExtent([o.value, i.value]).translateExtent(a.value), h = _e(B).call(F), b = h.on("wheel.zoom"), z = gt.translate(r.value.x ?? 0, r.value.y ?? 0).scale(ct(r.value.zoom ?? 1, o.value, i.value)), O = [
        [0, 0],
        [k.width, k.height]
      ], V = F.constrain()(z, O, a.value);
      F.transform(h, V), C.value({
        d3Zoom: F,
        d3Selection: h,
        d3ZoomHandler: b,
        viewport: { x: V.x, y: V.y, zoom: V.k },
        viewportRef: B
      }), _t(u.value, (N) => {
        H.value = N;
      });
      const Z = _t(s.value);
      An(() => {
        H.value && G.value && !te.value ? F.on("zoom", null) : !H.value && !G.value && F.on("zoom", (N) => {
          C.value({ viewport: { x: N.transform.x, y: N.transform.y, zoom: N.transform.k } });
          const Q = j(N.transform);
          q.value = D(f.value, m.value ?? 0), T.value.viewportChange(Q), T.value.move({ event: N, flowTransform: Q });
        });
      }), F.on("start", (N) => {
        var ee;
        if (!N.sourceEvent)
          return null;
        m.value = N.sourceEvent.button, te.value = !0;
        const Q = j(N.transform);
        ((ee = N.sourceEvent) == null ? void 0 : ee.type) === "mousedown" && C.value({ paneDragging: !0 }), Y.value = Q, T.value.viewportChangeStart(Q), T.value.moveStart({ event: N, flowTransform: Q });
      }), F.on("end", (N) => {
        if (!N.sourceEvent)
          return null;
        if (te.value = !1, C.value({ paneDragging: !1 }), D(f.value, m.value ?? 0) && !q.value && T.value.paneContextMenu(N.sourceEvent), q.value = !1, U(Y.value, N.transform)) {
          const Q = j(N.transform);
          Y.value = Q, T.value.viewportChangeEnd(Q), T.value.moveEnd({ event: N, flowTransform: Q });
        }
      }), An(() => {
        g.value && !Z.value && !G.value ? h.on(
          "wheel.zoom",
          (N) => {
            if (re(N, A.value))
              return !1;
            N.preventDefault(), N.stopImmediatePropagation();
            const Q = h.property("__zoom").k || 1;
            if (N.ctrlKey && _.value) {
              const kt = Se(N), xr = -N.deltaY * (N.deltaMode === 1 ? 0.05 : N.deltaMode ? 1 : 2e-3) * 10, _r = Q * 2 ** xr;
              F.scaleTo(h, _r, kt);
              return;
            }
            const ee = N.deltaMode === 1 ? 20 : 1, se = v.value === Xt.Vertical ? 0 : N.deltaX * ee, fe = v.value === Xt.Horizontal ? 0 : N.deltaY * ee;
            F.translateBy(h, -(se / Q) * w.value, -(fe / Q) * w.value);
          },
          { passive: !1 }
        ) : typeof b < "u" && h.on(
          "wheel.zoom",
          function(N, Q) {
            if (!S.value || re(N, A.value))
              return null;
            N.preventDefault(), b.call(this, N, Q);
          },
          { passive: !1 }
        );
      }), F.filter((N) => {
        var fe, kt;
        const Q = Z.value || y.value, ee = _.value && N.ctrlKey;
        if (N.button === 1 && N.type === "mousedown" && ((fe = N.target) != null && fe.closest(".vue-flow__node") || (kt = N.target) != null && kt.closest(".vue-flow__edge")))
          return !0;
        if (!f.value && !Q && !g.value && !d.value && !_.value || G.value || !d.value && N.type === "dblclick" || re(N, A.value) && N.type === "wheel" || re(N, x.value) && N.type !== "wheel" || !_.value && N.ctrlKey && N.type === "wheel" || !Q && !g.value && !ee && N.type === "wheel" || !f.value && (N.type === "mousedown" || N.type === "touchstart") || Array.isArray(f.value) && !f.value.includes(N.button) && (N.type === "mousedown" || N.type === "touchstart"))
          return !1;
        const se = Array.isArray(f.value) && f.value.includes(N.button) || !N.button || N.button <= 1;
        return (!N.ctrlKey || N.type === "wheel") && se;
      });
    });
    function D(B, k) {
      return k === 2 && Array.isArray(B) && B.includes(2);
    }
    function U(B, k) {
      return B.x !== k.x && !isNaN(k.x) || B.y !== k.y && !isNaN(k.y) || B.zoom !== k.k && !isNaN(k.k);
    }
    function j(B) {
      return {
        x: B.x,
        y: B.y,
        zoom: B.k
      };
    }
    function ie() {
      if (!I.value)
        return;
      const { width: B, height: k } = nn(I.value);
      (B === 0 || k === 0) && T.value.error(new ve(he.MISSING_VIEWPORT_DIMENSIONS)), l.value.width = B || 500, l.value.height = k || 500;
    }
    function re(B, k) {
      return B.target.closest(`.${k}`);
    }
    return (B, k) => (oe(), ae(Ne, null, [
      (oe(), ae("div", {
        ref_key: "viewportEl",
        ref: I,
        key: `viewport-${M(n)}`,
        class: "vue-flow__viewport vue-flow__container"
      }, [
        je(id, {
          "is-selecting": M(K),
          class: qe({ connecting: M($), dragging: M(R), draggable: !!M(f) })
        }, {
          default: Ge(() => [
            je(_d, null, {
              default: Ge(() => [
                ye(B.$slots, "zoom-pane")
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["is-selecting", "class"])
      ])),
      ye(B.$slots, "default")
    ], 64));
  }
}), Ed = ["id"], Sd = ["id"], Nd = ["id"], Cd = {
  name: "A11yDescriptions",
  compatConfig: { MODE: 3 }
}, Md = /* @__PURE__ */ ge({
  ...Cd,
  setup(e) {
    const { id: t, disableKeyboardA11y: n, ariaLiveMessage: o } = ce(), i = {
      position: "absolute",
      width: 1,
      height: 1,
      margin: -1,
      border: 0,
      padding: 0,
      overflow: "hidden",
      clip: "rect(0px, 0px, 0px, 0px)",
      clipPath: "inset(100%)"
    };
    return (r, a) => (oe(), ae(Ne, null, [
      st("div", {
        id: `${M(ji)}-${M(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select a node. " + Bn(M(n) ? "" : "You can then use the arrow keys to move the node around.") + " You can then use the arrow keys to move the node around, press delete to remove it and press escape to cancel. ", 9, Ed),
      st("div", {
        id: `${M(Qi)}-${M(t)}`,
        style: { display: "none" }
      }, " Press enter or space to select an edge. You can then press delete to remove it or press escape to cancel. ", 8, Sd),
      M(n) ? be("", !0) : (oe(), ae("div", {
        key: 0,
        id: `${M(Ns)}-${M(t)}`,
        "aria-live": "assertive",
        "aria-atomic": "true",
        style: i
      }, Bn(M(o)), 9, Nd))
    ], 64));
  }
}), $d = {
  name: "VueFlow",
  compatConfig: { MODE: 3 }
}, Hd = /* @__PURE__ */ ge({
  ...$d,
  props: {
    id: null,
    modelValue: null,
    nodes: null,
    edges: null,
    edgeTypes: null,
    nodeTypes: null,
    connectionMode: null,
    connectionLineType: null,
    connectionLineStyle: { default: void 0 },
    connectionLineOptions: { default: void 0 },
    connectionRadius: null,
    isValidConnection: { type: [Function, null], default: void 0 },
    deleteKeyCode: null,
    selectionKeyCode: null,
    multiSelectionKeyCode: null,
    zoomActivationKeyCode: null,
    panActivationKeyCode: null,
    snapToGrid: { type: Boolean, default: void 0 },
    snapGrid: null,
    onlyRenderVisibleElements: { type: Boolean, default: void 0 },
    edgesUpdatable: { type: [Boolean, String], default: void 0 },
    nodesDraggable: { type: Boolean, default: void 0 },
    nodesConnectable: { type: Boolean, default: void 0 },
    elementsSelectable: { type: Boolean, default: void 0 },
    selectNodesOnDrag: { type: Boolean, default: void 0 },
    panOnDrag: { type: [Boolean, Array], default: void 0 },
    minZoom: null,
    maxZoom: null,
    defaultViewport: null,
    translateExtent: null,
    nodeExtent: null,
    defaultMarkerColor: null,
    zoomOnScroll: { type: Boolean, default: void 0 },
    zoomOnPinch: { type: Boolean, default: void 0 },
    panOnScroll: { type: Boolean, default: void 0 },
    panOnScrollSpeed: null,
    panOnScrollMode: null,
    zoomOnDoubleClick: { type: Boolean, default: void 0 },
    preventScrolling: { type: Boolean, default: void 0 },
    selectionMode: null,
    edgeUpdaterRadius: null,
    fitViewOnInit: { type: Boolean, default: void 0 },
    connectOnClick: { type: Boolean, default: void 0 },
    applyDefault: { type: Boolean, default: void 0 },
    autoConnect: { type: [Boolean, Function], default: void 0 },
    noDragClassName: null,
    noWheelClassName: null,
    noPanClassName: null,
    defaultEdgeOptions: null,
    elevateEdgesOnSelect: { type: Boolean, default: void 0 },
    elevateNodesOnSelect: { type: Boolean, default: void 0 },
    disableKeyboardA11y: { type: Boolean, default: void 0 },
    edgesFocusable: { type: Boolean, default: void 0 },
    nodesFocusable: { type: Boolean, default: void 0 },
    autoPanOnConnect: { type: Boolean, default: void 0 },
    autoPanOnNodeDrag: { type: Boolean, default: void 0 },
    __experimentalFeatures: null
  },
  emits: ["nodesChange", "edgesChange", "nodeDoubleClick", "nodeClick", "nodeMouseEnter", "nodeMouseMove", "nodeMouseLeave", "nodeContextMenu", "nodeDragStart", "nodeDrag", "nodeDragStop", "nodesInitialized", "miniMapNodeClick", "miniMapNodeDoubleClick", "miniMapNodeMouseEnter", "miniMapNodeMouseMove", "miniMapNodeMouseLeave", "connect", "connectStart", "connectEnd", "clickConnectStart", "clickConnectEnd", "moveStart", "move", "moveEnd", "selectionDragStart", "selectionDrag", "selectionDragStop", "selectionContextMenu", "selectionStart", "selectionEnd", "viewportChangeStart", "viewportChange", "viewportChangeEnd", "paneReady", "paneScroll", "paneClick", "paneContextMenu", "paneMouseEnter", "paneMouseMove", "paneMouseLeave", "edgeContextMenu", "edgeMouseEnter", "edgeMouseMove", "edgeMouseLeave", "edgeDoubleClick", "edgeClick", "edgeUpdateStart", "edgeUpdate", "edgeUpdateEnd", "updateNodeInternals", "error", "update:modelValue", "update:nodes", "update:edges"],
  setup(e, { expose: t, emit: n }) {
    const o = e, i = xt(o, "modelValue", n), r = xt(o, "nodes", n), a = xt(o, "edges", n), { vueFlowRef: l, hooks: s, getNodeTypes: u, getEdgeTypes: c, ...g } = ce(o), v = nd({ modelValue: i, nodes: r, edges: a }, o, {
      vueFlowRef: l,
      hooks: s,
      getNodeTypes: u,
      getEdgeTypes: c,
      ...g
    });
    ua(n, s);
    const w = ne();
    return lt(an, Ir()), Or(() => {
      v();
    }), Ve(() => {
      l.value = w.value;
    }), t({
      vueFlowRef: l,
      hooks: s,
      getNodeTypes: u,
      getEdgeTypes: c,
      ...g
    }), (f, d) => (oe(), ae("div", {
      ref_key: "el",
      ref: w,
      class: "vue-flow"
    }, [
      je(bd, null, {
        nodes: Ge(() => [
          (oe(!0), ae(Ne, null, ut(Object.keys(M(u)), (_) => ye(f.$slots, `node-${_}`)), 256))
        ]),
        edges: Ge(() => [
          (oe(!0), ae(Ne, null, ut(Object.keys(M(c)), (_) => ye(f.$slots, `edge-${_}`)), 256))
        ]),
        "connection-name": Ge(() => [
          ye(f.$slots, "connection-line")
        ]),
        "zoom-pane": Ge(() => [
          ye(f.$slots, "zoom-pane")
        ]),
        default: Ge(() => [
          ye(f.$slots, "default")
        ]),
        _: 3
      }),
      je(Md)
    ], 512));
  }
}), kd = {
  name: "Panel",
  compatConfig: { MODE: 3 }
}, Ld = /* @__PURE__ */ ge({
  ...kd,
  props: {
    position: null
  },
  setup(e) {
    const t = e, { userSelectionActive: n } = ce(), o = W(() => `${t.position}`.split("-"));
    return (i, r) => (oe(), ae("div", {
      class: qe(["vue-flow__panel", M(o)]),
      style: Le({ pointerEvents: M(n) ? "none" : "all" })
    }, [
      ye(i.$slots, "default")
    ], 6));
  }
}), Dn = 0.1, Fd = (e) => {
  const t = ce({ id: e }), n = E(t, "nodes"), o = E(t, "d3Zoom"), i = E(t, "d3Selection"), r = E(t, "dimensions"), a = E(t, "translateExtent"), l = E(t, "minZoom"), s = E(t, "maxZoom"), u = E(t, "viewport"), c = E(t, "snapToGrid"), g = E(t, "snapGrid"), v = E(t, "getNodes");
  return {
    zoomIn: (d) => {
      w(1.2, d == null ? void 0 : d.duration);
    },
    zoomOut: (d) => {
      w(1 / 1.2, d == null ? void 0 : d.duration);
    },
    zoomTo: (d, _) => {
      i.value && o.value && o.value.scaleTo(zn(i.value, _ == null ? void 0 : _.duration), d);
    },
    setTransform: (d, _) => {
      f(d.x, d.y, d.zoom, _ == null ? void 0 : _.duration);
    },
    getTransform: () => ({
      x: u.value.x,
      y: u.value.y,
      zoom: u.value.zoom
    }),
    fitView: (d = {
      padding: Dn,
      includeHiddenNodes: !1,
      duration: 0
    }) => {
      if (!n.value.length)
        return;
      const _ = (d.includeHiddenNodes ? n.value : v.value).filter((C) => {
        var G;
        const T = C.initialized && C.dimensions.width && C.dimensions.height;
        let p = !0;
        return (G = d.nodes) != null && G.length && (p = d.nodes.includes(C.id)), T && p;
      }), y = uo(_), { x: S, y: A, zoom: x } = Yt(
        y,
        r.value.width,
        r.value.height,
        d.minZoom ?? l.value,
        d.maxZoom ?? s.value,
        d.padding ?? Dn,
        d.offset
      );
      f(S, A, x, d == null ? void 0 : d.duration);
    },
    setCenter: (d, _, y) => {
      const S = typeof (y == null ? void 0 : y.zoom) < "u" ? y.zoom : s.value, A = r.value.width / 2 - d * S, x = r.value.height / 2 - _ * S;
      f(A, x, S, y == null ? void 0 : y.duration);
    },
    fitBounds: (d, _ = { padding: Dn }) => {
      const { x: y, y: S, zoom: A } = Yt(d, r.value.width, r.value.height, l.value, s.value, _.padding);
      f(y, S, A, _ == null ? void 0 : _.duration);
    },
    project: (d) => so(d, u.value, c.value, g.value)
  };
  function w(d, _) {
    i.value && o.value && o.value.scaleBy(zn(i.value, _), d);
  }
  function f(d, _, y, S) {
    const { x: A, y: x } = ro({ x: -d, y: -_ }, a.value), C = gt.translate(-A, -x).scale(y);
    i.value && o.value && o.value.transform(zn(i.value, S), C);
  }
};
function zn(e, t = 0) {
  return e.transition().duration(t);
}
function Gd(e) {
  const t = e ?? He(Ii, ""), n = He(Oi, null), { findEdge: o, emits: i } = ce(), r = o(t);
  return r || i.error(new ve(he.EDGE_NOT_FOUND, t)), {
    id: t,
    edge: r,
    edgeEl: n
  };
}
export {
  hn as BaseEdge,
  zs as BezierEdge,
  Xe as ConnectionLineType,
  Qe as ConnectionMode,
  Bd as EdgeLabelRenderer,
  Ds as EdgeText,
  he as ErrorCode,
  tt as GlobalVueFlowStorage,
  Zt as Handle,
  Fn as MarkerType,
  $i as NodeIdInjection,
  Xt as PanOnScrollMode,
  Ld as Panel,
  pa as PanelPosition,
  J as Position,
  co as SelectionMode,
  As as SimpleBezierEdge,
  or as SmoothStepEdge,
  Hs as StepEdge,
  Ls as StraightEdge,
  Hd as VueFlow,
  ve as VueFlowError,
  Po as VueFlowInjection,
  Pd as addEdge,
  en as applyChanges,
  Rd as applyEdgeChanges,
  Vd as applyNodeChanges,
  ct as clamp,
  Ei as connectionExists,
  au as defaultEdgeTypes,
  ru as defaultNodeTypes,
  tr as getBezierEdgeCenter,
  Zn as getBezierPath,
  zd as getBoundsofRects,
  rn as getConnectedEdges,
  Td as getIncomers,
  Ue as getMarkerId,
  Ci as getNodesInside,
  Od as getOutgoers,
  uo as getRectOfNodes,
  nr as getSimpleBezierPath,
  er as getSimpleEdgeCenter,
  Kn as getSmoothStepPath,
  ir as getStraightPath,
  Yt as getTransformForBounds,
  Ad as graphPosToZoomedPos,
  De as isEdge,
  wi as isGraphEdge,
  Re as isGraphNode,
  ao as isNode,
  Dd as updateEdge,
  Gd as useEdge,
  Aa as useGetPointerPosition,
  Di as useHandle,
  ma as useNode,
  ce as useVueFlow,
  Fd as useZoomPanHelper
};
